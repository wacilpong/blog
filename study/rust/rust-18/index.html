<!DOCTYPE html>
<html lang="kr-ko">
    <head>
        <meta name="description" content="Patterns and Matching" />

<meta name="og:type" content="website" />
<meta property="og:title" content="After reading Rust book chapter 18" />
<meta property="og:site_name" content="After reading Rust book chapter 18" />
<meta property="og:description" content="Patterns and Matching" />
<meta property="og:url" content="https://wacilpong.github.io/blog/study/rust/rust-18/" />

<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="After reading Rust book chapter 18" />
<meta name="twitter:description" content="Patterns and Matching" />

<meta property="og:image" content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512" />
<meta
  property="twitter:image:src"
  content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512"
/>


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-171393148-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());

  gtag("config", "UA-171393148-1");
</script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>After reading Rust book chapter 18</title>
        
            <link rel="icon" href="https://wacilpong.github.io/blog/favicon.ico">
        
        <style>

    html body {
        font-family: 'Raleway', sans-serif;
        background-color: white;
    }

    :root {
        --accent: #469160;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://wacilpong.github.io/blog/css/main.css">


 <link rel="stylesheet" href="https://wacilpong.github.io/blog/css/custom.css"> 


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.73.0" />
        

        

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">After reading Rust book chapter 18</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/blog/">Home</a></li>
                            
                                <li><a href="/blog/tags/">Category</a></li>
                            
                                <li><a href="/blog/post/">Posts</a></li>
                            
                                <li><a href="/blog/project/">Projects</a></li>
                            
                                <li><a href="/blog/learned/">What I Learned</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wacilpong/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/areum-han-a10645118/"><i class="fa fa-linkedin"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2>After reading Rust book chapter 18</h2>
        <h5></h5>
        
<a href="https://wacilpong.github.io/blog/tags/rust"><kbd class="item-tag">rust</kbd></a>


    </div>

    <div align="start" class="content"><h2 id="all-the-places-patterns-can-be-used">All the Places Patterns Can Be Used</h2>
<h3 id="1-1-match-arms">1-1. match Arms</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">match</span> VALUE {
    PATTERN <span style="color:#f92672">=&gt;</span> EXPRESSION,
    PATTERN <span style="color:#f92672">=&gt;</span> EXPRESSION,
    PATTERN <span style="color:#f92672">=&gt;</span> EXPRESSION,
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">match</span> x {
    None <span style="color:#f92672">=&gt;</span> None,
    Some(i) <span style="color:#f92672">=&gt;</span> Some(i <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>),
}
</code></pre></div><ul>
<li>match 표현식에 사용된 값에 대한 모든 가능성을 반드시 처리해야 한다.</li>
<li>마지막 가지에는 나머지 모든 경우를 처리한다.</li>
<li><code>_</code> 패턴은 모든 값과 일치하는 패턴이나, 변수에 바인딩되지 않으므로 마지막 가지에 쓴다.</li>
</ul>
<p><br /></p>
<h3 id="1-2-conditional-if-let-expressions">1-2. Conditional <code>if let</code> Expressions</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> favorite_color: Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> None;
    <span style="color:#66d9ef">let</span> is_tuesday <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;
    <span style="color:#66d9ef">let</span> age: Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">u8</span>, _<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> <span style="color:#e6db74">&#34;34&#34;</span>.parse();

    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(color) <span style="color:#f92672">=</span> favorite_color {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Using your favorite color, {color}, as the background&#34;</span>);
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> is_tuesday {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Tuesday is green day!&#34;</span>);
    } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(age) <span style="color:#f92672">=</span> age {
        <span style="color:#66d9ef">if</span> age <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">30</span> {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Using purple as the background color&#34;</span>);
        } <span style="color:#66d9ef">else</span> {
            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Using orange as the background color&#34;</span>);
        }
    } <span style="color:#66d9ef">else</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Using blue as the background color&#34;</span>);
    }
}
</code></pre></div><ul>
<li>favorite_color가 None이 아닐 때까지 <code>if문</code> 로직을 수행한다.
<ul>
<li>None이면 is_tuesday가 true이면 <code>else-if문</code> 로직을 수행한다.</li>
<li>false이면 파싱된 age값이 Err가 아닐 때까지 <code>else-if-let</code> 로직을 수행한다.</li>
<li>모든 예외 경우에 <code>else문</code> 로직을 수행한다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="1-3-conditional-while-let-loops">1-3. Conditional <code>while let</code> Loops</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> stack <span style="color:#f92672">=</span> Vec::new();

stack.push(<span style="color:#ae81ff">1</span>);
stack.push(<span style="color:#ae81ff">2</span>);
stack.push(<span style="color:#ae81ff">3</span>);

<span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(top) <span style="color:#f92672">=</span> stack.pop() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, top);
}
</code></pre></div><ul>
<li>stack의 값이 None이 아닐 때까지 반복문 로직을 수행한다.</li>
<li>만약 stack이 비면 None을 반환하게 된다.</li>
</ul>
<p><br /></p>
<h4 id="for-loops">for loops</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> v <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#e6db74">&#39;a&#39;</span>, <span style="color:#e6db74">&#39;b&#39;</span>, <span style="color:#e6db74">&#39;c&#39;</span>];

<span style="color:#66d9ef">for</span> (index, value) <span style="color:#66d9ef">in</span> v.iter().enumerate() {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{} is at index {}&#34;</span>, value, index);
}
</code></pre></div><ul>
<li>for문 바로 뒤에 오는 키워드는 패턴이어서 튜플로 구조화할 수 있다.</li>
<li>이때 index, value는 <code>enumerate</code>메서드가 반환하는 인덱스와 값으로 매칭된다.</li>
</ul>
<p><br /></p>
<h3 id="1-4-let-statements">1-4. <code>let</code> Statements</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// (1) 성공
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> (x, y, z) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);

<span style="color:#75715e">// (2) 에러
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> (x, y) <span style="color:#f92672">=</span> (<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>);
</code></pre></div><ul>
<li>(2)는 아래처럼 에러를 낸다.<br />
<em>this expression has type <code>({integer}, {integer}, {integer})</code></em></li>
<li>이를 수정하려면 <code>_</code>, <code>..</code>처럼 패턴에서 무시할 수 있는 값을 쓰면 된다.</li>
</ul>
<p><br /></p>
<h3 id="1-5-function-parameters">1-5. Function Parameters</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">foo</span>(x: <span style="color:#66d9ef">i32</span>) {
    <span style="color:#75715e">// code goes here
</span><span style="color:#75715e"></span>}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">print_coordinates</span>(<span style="color:#f92672">&amp;</span>(x, y): <span style="color:#66d9ef">&amp;</span>(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>)) {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Current location: ({}, {})&#34;</span>, x, y);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> point <span style="color:#f92672">=</span> (<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">5</span>);
    print_coordinates(<span style="color:#f92672">&amp;</span>point);
}
</code></pre></div><ul>
<li>함수 괄호에 오는 x 인자 부분이 바로 패턴이다.</li>
</ul>
<p><br /></p>
<hr />
<h2 id="refutability-패턴-매칭에-실패할까-아닐까">Refutability: 패턴 매칭에 실패할까, 아닐까?</h2>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> some_option_value: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> None;

    <span style="color:#75715e">// (1)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> Some(x) <span style="color:#f92672">=</span> some_option_value;

    <span style="color:#75715e">// (2)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(x) <span style="color:#f92672">=</span> some_option_value {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, x);
    }

    <span style="color:#75715e">// (3)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, x);
    };
}
</code></pre></div><ul>
<li>(1)은 let Some(x)가 None인 경우 커버하지 못하므로 컴파일되지 않는다.<br />
<em>refutable pattern in local binding: <code>None</code> not covered</em></li>
<li>(2)애서 실패 가능한 경우를 커버했으므로 컴파일된다.</li>
<li>(3)처럼 항상 실패하지 않는 패턴도 러스트 입장에선 논리적으로 맞지 않아 컴파일되지 않는다.<br />
<em>irrefutable <code>if let</code> pattern</em></li>
</ul>
<p><br /></p>
<hr />
<h2 id="pattern-syntax">Pattern Syntax</h2>
<h3 id="3-1-리터럴과-매칭하기">3-1. 리터럴과 매칭하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#75715e">// 패턴은 리터럴에 직접 비교할 수 있다.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">match</span> <span style="color:#f92672">**</span>x<span style="color:#f92672">**</span> {
    <span style="color:#ae81ff">1</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;하나&#34;</span>),
    <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;둘&#34;</span>),
    <span style="color:#ae81ff">3</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;셋&#34;</span>),
    _ <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;나머지&#34;</span>),
</code></pre></div><p><br /></p>
<h3 id="3-2-명명된-변수와-매칭하기">3-2. 명명된 변수와 매칭하기</h3>
<ul>
<li>명명된 변수는 모든 값과 일치하는 패턴이므로 match 표현식에서 사용하는 것은 복잡하다.</li>
<li>match 표현식은 새 스코프를 생성하므로 패턴으로 선언한 변수는 표현식 바깥에 선언된 같은 이름의 변수를 shadowing한다.</li>
</ul>
<p><br /></p>
<h4 id="출력-결과-예측하기">출력 결과 예측하기?</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> Some(<span style="color:#ae81ff">5</span>);
    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    <span style="color:#66d9ef">match</span> x {
        Some(<span style="color:#ae81ff">50</span>) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;50&#34;</span>),

        <span style="color:#75715e">// 변수 y는 앞서 10을 대입한 변수 y가 아니라 새로운 변수
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// y는 Some 값에 저장된 모든 값과 일치
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// y에 Some 값 안에 저장된 변수 x의 값이 바인딩된다.
</span><span style="color:#75715e"></span>        Some(y) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;일치, y = {:?}&#34;</span>, y),
        _ <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;일치하지 않음, x = {:?}&#34;</span>, x),
    }

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;결과: x = {:?}, y = {:?}&#34;</span>, x, y);
    <span style="color:#75715e">// 출력결과: 일치, y = 5
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 결과: x = Some(5), y = 10
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>shadow 변수를 생성하지 않고 외부의 변수 x와 y의 값을 비교하기 위한 match 표현식을 생성하려면 매치 가드(match guard)를 대신 사용하면 된다.</li>
</ul>
<p><br /></p>
<h3 id="3-3-다중-패턴">3-3. 다중 패턴</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">match</span> x {
    <span style="color:#ae81ff">1</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">2</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;1 또는 2&#34;</span>),
    <span style="color:#ae81ff">3</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;3&#34;</span>),
    _ <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;그 외 나머지 값&#34;</span>),
}
</code></pre></div><ul>
<li>match 표현식에는 or의 의미가 있는 | 문법을 이용해 여러개의 패턴을 비교할 수 있다.</li>
</ul>
<p><br /></p>
<h3 id="3-4--문법으로-범위-값과-매칭하기">3-4. <code>..=</code> 문법으로 범위 값과 매칭하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;

    <span style="color:#66d9ef">match</span> x {
        <span style="color:#ae81ff">1</span>..<span style="color:#f92672">=</span><span style="color:#ae81ff">5</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;one through five&#34;</span>),
        _ <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;something else&#34;</span>),
    }
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#e6db74">&#39;c&#39;</span>;

    <span style="color:#66d9ef">match</span> x {
        <span style="color:#e6db74">&#39;a&#39;</span>..<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;j&#39;</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;early ASCII letter&#34;</span>),
        <span style="color:#e6db74">&#39;k&#39;</span>..<span style="color:#f92672">=</span><span style="color:#e6db74">&#39;z&#39;</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;late ASCII letter&#34;</span>),
        _ <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;something else&#34;</span>),
    }
}
</code></pre></div><ul>
<li>가장자리의 값을 포함하는 값의 범위와 비교하며, 1부터 1000처럼 큰 범위일 때 유용하다.</li>
<li>범위는 숫자나 char 값만 사용할 수 있다.</li>
<li>컴파일 타임에 범위가 비어있지 않은지 검사해야 하기 때문이다.</li>
<li>범위가 비어있는지 러스트가 판단할 수 있는 타입은 char 타입과 숫자 뿐이다.</li>
</ul>
<p><br /></p>
<h3 id="3-5-값을-분리하여-destructuring">3-5. 값을 분리하여 Destructuring</h3>
<ul>
<li>패턴은 구조체, 열거자, 튜플, 그리고 참조 destructuring 용도로 사용할 수 있다.</li>
</ul>
<p><br /></p>
<h4 id="구조체의-해체">구조체의 해체</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
    x: <span style="color:#66d9ef">i32</span>,
    y: <span style="color:#66d9ef">i32</span>,
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> p <span style="color:#f92672">=</span> Point {x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">7</span> };

    <span style="color:#75715e">// 변수 p에 저장된 구조체의 x와 y필드값에 일치하는 변수 a와 b를 생성한다.
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> Point {x: <span style="color:#f92672">**</span>a<span style="color:#f92672">**</span>, y: <span style="color:#f92672">**</span>b<span style="color:#f92672">**</span> } <span style="color:#f92672">=</span> p;
    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">0</span>, a);
    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">7</span>, b);
}
</code></pre></div><ul>
<li>패턴에 사용하는 변수 이름은 구조체의 필드 이름과 반드시 일치할 필요는 없다.</li>
<li>하지만 쉽게 기억하기 위해 필드이름과 같은 이름의 변수를 사용하는 것이 일반적이다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
    x: <span style="color:#66d9ef">i32</span>,
    y: <span style="color:#66d9ef">i32</span>,
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> p <span style="color:#f92672">=</span> Point {x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">7</span> };

    <span style="color:#75715e">// let Point { x: x, y: y } = p; 대신
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> Point { <span style="color:#f92672">**</span>x, y<span style="color:#f92672">**</span> } <span style="color:#f92672">=</span> p;
    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">0</span>, a);
    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">7</span>, b);
}
</code></pre></div><ul>
<li>모든 필드를 위한 변수를 생성하지 않고 구조체 패턴에 리터럴 값을 이용해서 해체할 수 있다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
    x: <span style="color:#66d9ef">i32</span>,
    y: <span style="color:#66d9ef">i32</span>,
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> p <span style="color:#f92672">=</span> Point { x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">7</span> }:

    <span style="color:#a6e22e">match</span> p {
        <span style="color:#75715e">// y 필드값이 0 이면서 x 필드값은 어떤 값이든 일치하는 경우, 변수 x를 생성
</span><span style="color:#75715e"></span>        Point { x, y: <span style="color:#ae81ff">0</span> } <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;x 축 {}에 위치하는 점&#34;</span>, x),
        <span style="color:#75715e">// x 필드값이 0 이면서 y 필드값은 어떤 값이든 일치하는 경우, 변수 y를 생성
</span><span style="color:#75715e"></span>        Point { x: <span style="color:#ae81ff">0</span>, y } <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;y 축 {}에 위치하는 점&#34;</span>, y),
        <span style="color:#75715e">// 위의 두 경우 제외한 모든 경우, 변수 x, y 모두 생성
</span><span style="color:#75715e"></span>        Point { x, y } <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;좌표 ({}, {})에 위치하는 점&#34;</span>, x, y),
    }
}
</code></pre></div><p><br /></p>
<h4 id="열거자의-해체">열거자의 해체</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// p.123
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Message</span> {
    Quit, <span style="color:#75715e">// 연관 데이터를 전혀 갖지 않는다.
</span><span style="color:#75715e"></span>    Move { x: <span style="color:#66d9ef">i32</span>, y: <span style="color:#66d9ef">i32</span> }, <span style="color:#75715e">// 익명 구조체를 포함
</span><span style="color:#75715e"></span>    Write(String), <span style="color:#75715e">// 하나의 String값을 포함
</span><span style="color:#75715e"></span>    ChangeColor(Color), <span style="color:#75715e">// 세 개의 i32값을 포함
</span><span style="color:#75715e"></span>}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> msg <span style="color:#f92672">=</span> Message::ChangeColor(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">160</span>, <span style="color:#ae81ff">255</span>);

    <span style="color:#66d9ef">match</span> msg {
        Message::Quit <span style="color:#f92672">=&gt;</span> {
            <span style="color:#75715e">// 데이터가 없는 열것값은 어떤 값도 해체할 수 없다. Message::Quit 리터럴 값에만 일치하므로 패턴에 변수도 포함하지 않는다.
</span><span style="color:#75715e"></span>            println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Quit: 해체할 값이 없습니다.&#34;</span>)
        },
        Message::Move { x, y } <span style="color:#f92672">=&gt;</span> {
            <span style="color:#75715e">// 구조체와 유사한 형태의 열것값은 구조체를 사용할 때와 유사한 패턴을 사용할 수 있다.
</span><span style="color:#75715e"></span>            println<span style="color:#f92672">!</span>(
                <span style="color:#e6db74">&#34;Move: x = {}, y = {}&#34;</span>,
                x,
                y
            );
        },
        Message::Write(text) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Write: {}&#34;</span>, text),
        Message::ChangeColor(r, g, b) <span style="color:#f92672">=&gt;</span> {
            println<span style="color:#f92672">!</span>(
                <span style="color:#e6db74">&#34;ChangeColor: R = {}, G = {}, B = {}&#34;</span>,
                r,
                g,
                b
            )
        },
    }
}
</code></pre></div><ul>
<li>열거자를 해체하기 위한 패턴은 열거자에 데이터를 저장하는 방법을 정의한 것과 같아야 한다.</li>
</ul>
<p><br /></p>
<h4 id="중첩된-구조체와-열거자의-해체">중첩된 구조체와 열거자의 해체</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// ChangeColor 메시지가 RGB와 HSV 색상을 지원한다면
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Color</span> {
    Rgb(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>),
    Hsv(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>),
}

<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Message</span> {
    Quit,
    Move { x: <span style="color:#66d9ef">i32</span>, y: <span style="color:#66d9ef">i32</span> },
    Write(String),
    ChangeColor(<span style="color:#f92672">**</span>Color<span style="color:#f92672">**</span>),
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> msg <span style="color:#f92672">=</span> Message::ChangeColor(Color::Hsv(<span style="color:#ae81ff">0</span>, <span style="color:#ae81ff">160</span>, <span style="color:#ae81ff">255</span>));

    <span style="color:#66d9ef">match</span> msg {
        Message::ChangeColor(Color::Rgb(r, g, b)) <span style="color:#f92672">=&gt;</span> {
            println<span style="color:#f92672">!</span>(
                <span style="color:#e6db74">&#34;ChangeColor: R = {}, G = {}, B = {}&#34;</span>,
                r,
                g,
                b
            );
        },
        Message::ChangeColor(Color::Hsv(h, s, v)) <span style="color:#f92672">=&gt;</span> {
            println<span style="color:#f92672">!</span>(
                <span style="color:#e6db74">&#34;ChangeColor: H = {}, S = {}, V = {}&#34;</span>,
                h,
                s,
                v
            )
        },
        _ <span style="color:#f92672">=&gt;</span> {}
    },
}
</code></pre></div><p><br /></p>
<h4 id="구조체와-튜플의-해체">구조체와 튜플의 해체</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> ((feet, inches), Point {x, y}) <span style="color:#f92672">=</span> ((<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">10</span>), Point { x: <span style="color:#ae81ff">3</span>, y: <span style="color:#f92672">-</span><span style="color:#ae81ff">10</span> });
</code></pre></div><ul>
<li>헤체패턴은 더 복잡한 방법으로 섞거나 중첩할 수 있다.</li>
</ul>
<p><br /></p>
<h3 id="3-6-패턴의-값-무시하기">3-6. 패턴의 값 무시하기</h3>
<ul>
<li>패턴의 값 전체를 무시할 수도 있고, 일부만 무시할 수도 있다.</li>
</ul>
<p><br /></p>
<h4 id="_-패턴으로-값-전체-무시하기"><code>_</code> 패턴으로 값 전체 무시하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">foo</span>(_: <span style="color:#66d9ef">i32</span>, y: <span style="color:#66d9ef">i32</span>) {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;이 함수는 y 매개변수만 사용한다: {}&#34;</span>, y);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    foo(<span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>);
}
</code></pre></div><ul>
<li>match 표현식의 마지막 가지로도 사용할 수 있지만, 어떤 패턴에서도 사용할 수 있다.</li>
<li>ex. 어떤 트레이트의 시그너처를 구현하는데 함수의 본문에서 해당 매개변수가 필요치 않을 때</li>
</ul>
<p><br /></p>
<h4 id="_를-중첩해서-값의-일부만-무시하기"><code>_</code>를 중첩해서 값의 일부만 무시하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> setting_value <span style="color:#f92672">=</span> Some(<span style="color:#ae81ff">5</span>);
<span style="color:#66d9ef">let</span> new_setting_value <span style="color:#f92672">=</span> Some(<span style="color:#ae81ff">10</span>);

<span style="color:#66d9ef">match</span> (setting_value, new_setting_value) {
    <span style="color:#75715e">// 두 Some값에 저장된 실제 값은 사용하지 않지만, 모두 Some 값을 가지고 있는지만 검사한다.
</span><span style="color:#75715e"></span>    (Some(_), Some(_)) <span style="color:#f92672">=&gt;</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;이미 설정된 값을 덮어쓸 수 없습니다.&#34;</span>);
    }
    <span style="color:#75715e">// 그 외의 경우: 둘 중 하나가 None
</span><span style="color:#75715e"></span>    _ <span style="color:#f92672">=&gt;</span> {
        setting_value <span style="color:#f92672">=</span> new_setting_value;
    }
}

println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;현재 설정: {:?}&#34;</span>, setting_value);
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// 한 패턴에서 여러 번 사용해서 특정 값을 무시
</span><span style="color:#75715e"></span><span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">32</span>);

<span style="color:#66d9ef">match</span> numbers {
    (first, _, third, _, fifth) <span style="color:#f92672">=&gt;</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;일치하는 숫자: {}, {}, {}&#34;</span>, first, third, fifth)
    },
}
</code></pre></div><p><br /></p>
<h4 id="변수-이름을-_로-시작해-사용하지-않는-변수-무시하기">변수 이름을 <code>_</code>로 시작해 사용하지 않는 변수 무시하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> _x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>; <span style="color:#75715e">// y에 대해서만 경고가 출력된다.
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>러스트는 일단 선언한 변수를 사용하지 않으면 버그의 원인이 될 수 있으므로 경고를 출력한다.</li>
<li>필요 시 사용하지 않는 변수에 대해 러스트가 경고를 출력하지 않도록 하려면 변수명을 밑줄로 시작한다.</li>
<li>변수 이름으로 <code>_</code>만 사용하는 것과 밑줄로 시작하는 변수명을 사용하는 것은 차이가 있다.</li>
<li><code>_x</code>는 변수에 값을 바인딩하지만, <code>_</code>는 바인딩하지 않는다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> Some(String::from(<span style="color:#e6db74">&#34;&#34;</span>));

<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(_s) <span style="color:#f92672">=</span> s { <span style="color:#75715e">// 변수 s의 값이 _s로 이동하게 되어서
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;문자열을 찾았습니다.&#34;</span>);
}

println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, s); <span style="color:#75715e">// 변수 s를 더는 사용할 수 없다.
</span></code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> Some(String::from(<span style="color:#e6db74">&#34;&#34;</span>));

<span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(_) <span style="color:#f92672">=</span> s { <span style="color:#75715e">// 바인딩 되지 않음
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;문자열을 찾았습니다.&#34;</span>);
}

println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:?}&#34;</span>, s); <span style="color:#75715e">// 변수 s 사용 가능
</span></code></pre></div><p><br /></p>
<h4 id="를-이용해-값의-나머지를-무시하기"><code>..</code>를 이용해 값의 나머지를 무시하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Point</span> {
    x: <span style="color:#66d9ef">i32</span>,
    y: <span style="color:#66d9ef">i32</span>,
    z: <span style="color:#66d9ef">i32</span>,
}

<span style="color:#66d9ef">let</span> origin <span style="color:#f92672">=</span> Point { x: <span style="color:#ae81ff">0</span>, y: <span style="color:#ae81ff">0</span>, z: <span style="color:#ae81ff">0</span> };

<span style="color:#66d9ef">match</span> origin {
    Point { x, .. } <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;x = {}&#34;</span>, x),
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">32</span>);

<span style="color:#66d9ef">match</span> numbers {
    (first, .., last) <span style="color:#f92672">=&gt;</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;first = {}, last = {}&#34;</span>, first, last);
    },
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> numbers <span style="color:#f92672">=</span> (<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">4</span>, <span style="color:#ae81ff">8</span>, <span style="color:#ae81ff">16</span>, <span style="color:#ae81ff">32</span>);

<span style="color:#66d9ef">match</span> numbers {
    (.., second, ..) <span style="color:#f92672">=&gt;</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;second = {}&#34;</span>, second);
    },
}
<span style="color:#75715e">// error
</span></code></pre></div><ul>
<li>여러 부분으로 구성된 값에 대해서는 <code>..</code> 문법으로 값의 일부만 검사하고 나머지는 무시할 수 있다.</li>
<li>값을 무시하기 위해 밑줄을 나열할 필요가 없다.</li>
<li>러스트 관점에서 second 변수에 일치하는 값을 찾기 전/후 몇 개의 값을 무시해야 하는지 모른다.</li>
</ul>
<p><br /></p>
<h3 id="3-7-매치-가드를-이용한-추가-조건">3-7. 매치 가드를 이용한 추가 조건</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> num <span style="color:#f92672">=</span> Some(<span style="color:#ae81ff">4</span>);

<span style="color:#66d9ef">match</span> num {
    <span style="color:#75715e">// 패턴만으로는 if x &lt; 5를 표현할 수 없으므로 매치가드는 로직의 표현력을 한층 더 높여준다
</span><span style="color:#75715e"></span>    Some(x) <span style="color:#f92672">**</span><span style="color:#66d9ef">if</span> x <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">5</span><span style="color:#f92672">**</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;5보다 작은 값: {}&#34;</span>, x),
    Some(x) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, x),
    None <span style="color:#f92672">=&gt;</span> (),
}
</code></pre></div><ul>
<li>매치 가드는 match 표현식의 가지에 일치해야 할 패턴 외에도 추가적인 if 조건을 지정해서 그 조건이 일치할 때만 해당 가지의 코드를 실행한다.</li>
<li>패턴이 변수를 가리는 문제를 매치 가드를 이용해 해결할 수 있다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> Some(<span style="color:#ae81ff">5</span>);
    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    <span style="color:#66d9ef">match</span> x {
        Some(<span style="color:#ae81ff">50</span>) <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;50&#34;</span>),
        <span style="color:#75715e">// 새 변수 n을 생성해서 y(10)를 가리지 않고 값을 비교할 수 있다.
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 매치가드 n == y는 패턴이 아니며 그래서 새로운 변수를 생성하지 않는다.
</span><span style="color:#75715e"></span>        Some(<span style="color:#f92672">**</span>n<span style="color:#f92672">**</span>) <span style="color:#f92672">**</span><span style="color:#66d9ef">if</span> n <span style="color:#f92672">==</span> y<span style="color:#f92672">**</span> <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;일치, y = {:?}&#34;</span>, y),
        _ <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;일치하지 않음, x = {:?}&#34;</span>, x),
    }

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;결과: x = {:?}, y = {:?}&#34;</span>, x, y);
}
</code></pre></div><ul>
<li>매치가드에는 or 연산자 |를 이용해서 여러 패턴을 지정할 수 있다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">4</span>;
<span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#66d9ef">false</span>;

<span style="color:#66d9ef">match</span> x {
    <span style="color:#f92672">**</span><span style="color:#ae81ff">4</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">5</span> <span style="color:#f92672">|</span> <span style="color:#ae81ff">6</span><span style="color:#f92672">**</span> <span style="color:#66d9ef">if</span> y <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;예&#34;</span>),
    _ <span style="color:#f92672">=&gt;</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;아니오&#34;</span>),
}
</code></pre></div><ul>
<li>(4 | 5 | 6) if y …로 동작하고 4 | 5 | (6 if y)… 처럼 동작하지 않는다.</li>
</ul>
<p><br /></p>
<h3 id="3-8--바인딩">3-8. <code>@</code> 바인딩</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Message</span> {
    Helllo { id: <span style="color:#66d9ef">i32</span> },
}

<span style="color:#66d9ef">let</span> msg <span style="color:#f92672">=</span> Message::Hello { id: <span style="color:#ae81ff">5</span> };

<span style="color:#66d9ef">match</span> msg {
    Message::Hello { id: <span style="color:#a6e22e">id_variable</span> <span style="color:#f92672">@</span> <span style="color:#ae81ff">3</span>...<span style="color:#ae81ff">7</span> } <span style="color:#f92672">=&gt;</span> {
        <span style="color:#75715e">// 값이 범위 패턴과 일치하는지 확인하는 동시에
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 일치하는 값을 변수에 바인딩한다.
</span><span style="color:#75715e"></span>        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;id를 범위에서 찾았습니다: {}&#34;</span>, id_variable)
    },
    Message::Hello { id: <span style="color:#ae81ff">10</span>...<span style="color:#ae81ff">12</span> } <span style="color:#f92672">=&gt;</span> {
        <span style="color:#75715e">// 패턴에 명시된 범위에 속하는지만 검사하며
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// id 필드의 실제 값을 가진 변수를 선언하지 않는다.
</span><span style="color:#75715e"></span>        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;id를 다른 범위에서 찾았습니다.&#34;</span>)
    },
    Message::Hello { id } <span style="color:#f92672">=&gt;</span> {
        <span style="color:#75715e">// (구조체 필드를 간략하게 표기하는 문법을 사용해서)
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 변수를 범위없이 선언했으므로 id라는 이름의 변수로 그 값을 사용할 수 있고,
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// id 필드값을 비교하지 않으며 어떤 값이든 이 패턴과 일치하게 된다.
</span><span style="color:#75715e"></span>        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;다른 id {}를 찾았습니다.&#34;</span>, id)
    },
</code></pre></div><ul>
<li>@(앳) 연산자는 어떤 값이 패턴과 일치하는지를 비교하는 동시에 그 값을 가진 변수를 생성한다.</li>
</ul>
</div>

</main>

        <footer>
            <p class="copyright text-muted">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>.</p>
        </footer>

        

        
    </body>

</html>

