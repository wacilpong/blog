<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>rust on Roomy</title>
    <link>https://wacilpong.github.io/blog/tags/rust/</link>
    <description>Recent content in rust on Roomy</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>kr-ko</language>
    <lastBuildDate>Fri, 26 Aug 2022 00:00:00 +0000</lastBuildDate>
    
	<atom:link href="https://wacilpong.github.io/blog/tags/rust/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>After reading Rust book chapter 18</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-18/</link>
      <pubDate>Fri, 26 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-18/</guid>
      <description>All the Places Patterns Can Be Used 1-1. match Arms match VALUE { PATTERN =&amp;gt; EXPRESSION, PATTERN =&amp;gt; EXPRESSION, PATTERN =&amp;gt; EXPRESSION, } match x { None =&amp;gt; None, Some(i) =&amp;gt; Some(i + 1), } match 표현식에 사용된 값에 대한 모든 가능성을 반드시 처리해야 한다. 마지막 가지에는</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 17</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-17/</link>
      <pubDate>Mon, 22 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-17/</guid>
      <description>객체지향 언어의 특징 1-1. 데이터와 행위를 정의하는 객체 객체는 데이터와 그 데이터를 운영하는 절차(메서드)를 모아둔 개념이다. 구조체/열거자는 impl 블록을 통해 메</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 16</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-16/</link>
      <pubDate>Sat, 06 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-16/</guid>
      <description>다중 프로세서를 사용할 수록 동시성과 병렬 처리가 중요해지고 있다. 이 챕터에서 동시성을 말할 때 개념적으로 병렬 처리라고 생각해도 된다. 코드를 동시에 실행하기 위</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 15</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-15/</link>
      <pubDate>Fri, 22 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-15/</guid>
      <description>포인터(pointer)는 메모리에 주소를 가지고 있는 변수를 일컫는 보편적인 개념이다. 러스트에서 가장 대중적인 포인터는 &amp;amp;기호를 사용한 참조, 변</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 14</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-14/</link>
      <pubDate>Sun, 17 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-14/</guid>
      <description>릴리즈 프로필을 이용한 빌드 커스터마이징 // Cargo.toml [profile.dev] opt-level = 0 [profile.release] opt-level = 3 cargo build: dev 프로필을 사용하고, --release를 붙이면 release 프로필을 쓴다. opt-level: 러스트가 코드에 적</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 13</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-13/</link>
      <pubDate>Mon, 04 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-13/</guid>
      <description>클로저(Closures): 주변 환경을 캡처하는 익명함수 러스트의 클로저는 변수에 저장하거나 다른 함수에 인자로 전달하는 익명함수다. 일반 함수와 달리 클로</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 12</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-12/</link>
      <pubDate>Thu, 30 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-12/</guid>
      <description>Accepting Command Line Arguments Reading the Argument Values use std::env; fn main() { let args: Vec&amp;lt;String&amp;gt; = env::args().collect(); let query = &amp;amp;args[1]; let filename = &amp;amp;args[2]; println!(&amp;#34;검색어: {}&amp;#34;, query); println!(&amp;#34;대상 파일: {}&amp;#34;, filename); } 커맨</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 11</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-11/</link>
      <pubDate>Fri, 24 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-11/</guid>
      <description>러스트의 타입 시스템은 모든 종류의 incorrectness를 잡을 수 없다. 2를 더한 값을 반환하는 add_two 함수가 있을 때, 러스트는 이 함수가 의도한대로 동작하는</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 10</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-10/</link>
      <pubDate>Wed, 15 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-10/</guid>
      <description>Removing Duplication by Extracting a Function // (1) fn main() { let number_list = vec![34, 50, 25, 100, 65]; let mut largest = number_list[0]; for number in number_list { if number &amp;gt; largest { largest = number; } } println!(&amp;#34;The largest number is {}&amp;#34;, largest); } // (2) fn largest(list: &amp;amp;[i32]) -&amp;gt; i32 { let mut largest = list[0]; for &amp;amp;item in list { if item &amp;gt; largest { largest</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 9</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-9/</link>
      <pubDate>Sun, 12 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-9/</guid>
      <description>에러 발생 가능성을 인지하고 개발자가 코드를 컴파일하기 전에 에러를 처리하도록 유도한다. 다른 언어에서는 에러 구분없이 exception으로 처리한다. 러스</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 8</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-8/</link>
      <pubDate>Sun, 29 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-8/</guid>
      <description>Vector // (1) let v: Vec&amp;lt;i32&amp;gt; = Vec::new(); // (2) let v = vec![1, 2, 3]; // (3) let mut v = Vec::new(); v.push(5); v.push(6); v.push(7); v.push(8); 연속된 일련의 값을 저장하는 컬렉션, Vec&amp;lt;T&amp;gt; 모든 값은 메모리상에 연속으로 저장되고, 같은 타입의 값만 저</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 7</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-7/</link>
      <pubDate>Tue, 10 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-7/</guid>
      <description>기능들을 그룹화하고 구현을 캡슐화하는 과정을 통해 코드의 차원을 높일 수 있다. 코드의 어떤 부분을 다른 코드를 위해 공개/비공개할지 정해야 한다. 이는 스코프(s</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 6</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-6/</link>
      <pubDate>Tue, 26 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-6/</guid>
      <description>1. 대수적 타입(Algebraic data type) 러스트의 enum은 함수형 언어들의 대수자료형(algebraic data types)에 가깝다. 정수론은 각종 숫자의</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 5</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-5/</link>
      <pubDate>Mon, 18 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-5/</guid>
      <description>1. 구조체(Structs) 정의와 인스턴스 생성 struct User { active: bool, username: String, email: String, sign_in_count: u64, } fn main() { let user1 = User { email: String::from(&amp;#34;someone@example.com&amp;#34;), username: String::from(&amp;#34;someusername123&amp;#34;), active: true, sign_in_count: 1, }; let mut user2 = User { // same } user2.email = String::from(&amp;#34;anotheremail@example.com&amp;#34;); } 구조체는 튜플</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 4</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-4/</link>
      <pubDate>Wed, 13 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-4/</guid>
      <description>소유권 (Ownership) 배경 ownership은 rust가 메모리를 어떻게 관리하는지에 대해 제어하는 일련의 규칙이다. 가비지 컬렉터나 개발자가 임의로 메모리를 해제하는</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 3</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-3/</link>
      <pubDate>Tue, 05 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-3/</guid>
      <description>Variables and Mutability (1) let fn main() { let x = 5; println!(&amp;#34;The value of x is: {}&amp;#34;, x); x = 6; println!(&amp;#34;The value of x is: {}&amp;#34;, x); } rust에서 모든 변수는 기본적으로 불변하며, 안전하고 쉬운 코드를 작성하기 위함이다. 위</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 2</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-2/</link>
      <pubDate>Sun, 03 Apr 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-2/</guid>
      <description>guessing game 입출력 붙이기 use std::io; fn main() { println!(&amp;#34;Guess the number!&amp;#34;); println!(&amp;#34;Please input your guess.&amp;#34;); let mut guess = String::new(); io::stdin() .read_line(&amp;amp;mut guess) .expect(&amp;#34;Failed to read line&amp;#34;); println!(&amp;#34;You guessed: {}&amp;#34;, guess); } io는 prelude: rust standard library에 있다. rust에서 모든 변수는 불변(im</description>
    </item>
    
    <item>
      <title>After reading Rust book chapter 1</title>
      <link>https://wacilpong.github.io/blog/study/rust/rust-1/</link>
      <pubDate>Fri, 25 Mar 2022 00:00:00 +0000</pubDate>
      
      <guid>https://wacilpong.github.io/blog/study/rust/rust-1/</guid>
      <description>시작! rust같은 low-level의 언어를 공부하면 아래와 같은 점들을 공부할 수 있다. memory management: 메모리 관리 ex. ownership data representation: 모델링 전에 데이터를 어떻게 표현할지? concurrency:</description>
    </item>
    
  </channel>
</rss>