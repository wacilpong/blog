---
title: "After reading <from math to generic programming>"
date: "2020-12-30"
tags: ["review"]
draft: true
og_description: "알고리즘 산책을 읽고 내맘대로 정리해보았다."
---

by Alexander A. Stepanov, Daniel E. Rose

알고리즘 산책을 읽고 정리해놓고 싶은 것들을 적어놓는다.

<br />

#### 자연수의 합

- 삼각수는 첫 n개의 양의 정수를 나타내는 행들을 쌓아서 만들 수 있다.
- 직사각수는 삼각수에 n을 곱한다.
- 기하학적으로 직사각수는 n(n+1)이고, 이를 2로 나누면 삼각수가 된다.
- 따라서 1부터 자연수 n까지의 합은 n(n+1)/2가 된다.
- 자신을 제외한 모든 약수의 합이 자신과 같으면 완전수이다.

<br />

#### 유클리드 호제법

- 유클리드는 최소한의 단계로 최대한 다양하게 응용될 수 있는 결과를 이끄는 증명을 선호했다.
- 최대공측도(최대공약수) 구하기
  ```txt
  명제: 두 개의 서로 다른 양이 있을 때 더 작은 양을 더 큰 양에서 빼는 작업을 반복한 후에 남는 양이 그전 양을 측정할 수 없으면 두 양은 통분 불가능하다
  ```
  - 피타고라스 학파의 "최대공측도를 계산하는 절차가 영원히 종료되지 않으면 두 수 사이에는 최대공측도가 존재하지 않는다"는 결과와 같다.
  - `측도`는 선분 P,V가 있을 때 V를 유한 번 이어서 P를 표현할 수 있으면 V를 P의 측도라고 부른다.
  - `공측도`는 선분 P의 측도이면서 동시에 선분 V의 측도인 경우이다.
  - `최대공측도`는 공측도는 여러 개 있을 수 있는데, 그중 가장 큰 공측도이다.
  - 이는 추후 최대공약수와 같다.
  - **위 명제에 따라 계속 큰 쪽에서 작은 쪽을 빼는 방법이 유클리드 호제법이다.**
  - a와 b는 무한하지 않기 때문에 나눈 나머지를 재귀적으로 비교할 수 있다.
  - 이는 a와 b에 대해서 a <= nb를 만족하는 자연수 n이 존재한다는 `아르키메데스의 공리`로 증명된다.
    ```c++
    integer gcd(integer a, integer b) {
        while (b != interger(0)) {
            a = a % b;
            std::swap(a, b);
        }

        return a;
    }
    ```
  - 위 코드의 순환이 돌 때마다 최대공약수는 항상 같아야 한다.
  - 따라서 gcd(a0, b0) = gcd(b0, r1) = gcd(r1, r2) = ... = gcd(rn-1, rn)
  - **rn-1과 rn의 나머지는 종료 조건에 따라 0이므로 gcd(a0, b0) = ... = gcd(rn, 0) = rn**
  - 자바스크립트 재귀적 순환으로 최대공약수를 구할 경우 다음과 같다.
    ```js
      function gcd(a, b){
          const r = a % b;

          if (r > 0) {
            return gcd(b, r);
          }

          return b;
      }
    ```

<br />

#### 완전수, 소수
- 완전수란 어떤 정수 n 자신을 제외한 모든 약수(진약수)의 합이 n인 수
- 2^n - 1은 완전수의 원천이 되는 소수의 형태이다.
- 1536년 후달리쿠스 레기우스는 n = 11이면 소수가 아님을 밝혔다.
- 프랑스 수학자 메르센은 n <= 257에서만 2^n - 1이 소수라고 주장했다.
- 이러한 주장으로 **2^n - 1은 메르센 소수라고 불리며, 요즘도 큰 소수에 사용된다.**
- 페르마는 2^2^n + 1 형태로 나오는 소수를 연구했으나, 첫 5개만 소수이고 더이상 페르마 소수가 존재하지 않을거라 예측하는 의견이 많다.
- **페르마의 작은 정리 : p가 소수이면 0 < a < p인 a에 대해 a^p-1 -1은 p로 나누어떨어진다.**
- 위 정리를 통해 오일러는 소수가 아닌 합성수에 적용되는 법칙을 연구했다.
- **오일러의 정리 : a와 n이 서로소일 때 a^φ(n) - 1은 n으로 나누어떨어진다.**
  - 이때 φ(n)은 오일러 파이 함수로, n과 서로소인 수의 개수를 구할 수 있다.
  - φ(n) = n * (1 - 1/p1) * (1 - 1/p2) ... * (1 - 1/pm)이며, pm은 n의 소인수
  - ex. φ(10) = 10 * (1 - 1/2) * (1 - 1/5) = 10 * 1/2 * 4/5 = 4개!!
- 완전수 연구는 실생활에 아무 쓸 데도 없지만 이를 통해 페르마의 작은 정리 발견으로 이어졌다.
- 오일러는 페르마의 작은 정리를 보며서 특별한 경우(소수)를 넘어 일반적인 경우(정수)로 확장했다.
- 제네릭 프로그래밍도 똑같은 추상화 과정을 거치게 된다.
- 코드를 일반화하는 일은 정리나 정리의 증명을 일반화하는 것과 마찬가지다.

<br />


#### 이론과 모델
- 수학에서 `이론(theory)`이라는 용어는 매우 정확한 의미로 부여되고, 증명되지 않은 추측 같은 것이 아니다.
- `모형(model)`은 이론에 있는 모든 연산이 정의되어 있고, 이론의 모든 명제가 참인 원소들의 집합이다.
  - 모델은 어떤 이론의 특정한 구현이라고 할 수 있다.
  - 같은 알고리즘도 여러 방식으로 구현할 수 있는 것처럼, 한 이론에 대해 여러 모델이 있을 수 있다.
- 이론의 공리(axiom)가 적을수록 그만큼 더 다양한 방식으로 구현할 수 있다.
- 공리와 명제는 이론의 제약조건이므로 많아질수록 모두 만족하는 모델은 적어질 수밖에 없다.

<br />


#### 제네릭 알고리즘 유도 방법
- 좋은 코드를 만들기 위해서는 제대로 된 알고리즘을 찾고, 그것이 어떤 유형에 적용되는지 파악해야 한다.
- 코드를 작성할 때 그 형(int나 float처럼)을 알았지만, 후에 int로 작성한 코드를 unsigned int나 double에 대해서도 사용하도록 고쳐달라고 할지 모른다.
- 따라서 요구조건 매듭을 푸는 과정이 필요하다.
  ```c++
  int multi_acc4(int r, int n, int a) {
    while (true) {
      if (odd(n)) {
        r = r + a;
        if (n === 1) return r;
      }

      n = half(n);
      a = a + a;
    }
  }
  ```
  - 변수를 int로 선언했지만, 다른 double같은 형에 대해서도 돌아갈 수 있을 것이다.
  - 변수 r과 a는 덧셈을 지원하는 형이어야 한다.
  - 변수 n은 홀짝을 판별해야 하므로, 1과 비교하고 2로 나누는 연산이 가능해야 한다.
  - 따라서 r과 a는 같은 형이므로 A, n은 N으로 지칭할 수 있다.
- 위의 과정에 따라 조금 더 일반화된 형식으로 프로그램을 고칠 수 있다.
  ```c++
  template <typename A, typename N>
  A multiply_accumulate(A r, N n, A a) {
    while (true) {
      if (odd(n)) {
        r = r + a;
        if (n === 1) return r;
      }

      n = half(n);
      a = a + a;
    }
  }
  ```
- A에 대한 요구조건: 덧셈, 값으로 전달, 대입, +연산이 결합법칙을 성립
  - `+`는 원칙적으로는 결합법칙이 성립하는 연산이지만, 컴퓨터에서는 아닐 수도 있다.
  - w = (x + y) + z / w = x + (y + z)
  - -> z가 음수이고 값이 아주 크면 전자는 int범위를 벗어날 수 있지만 후자는 아니다.
  - 모든 int형의 값에 대해 덧셈이 제대로 정의되어 있지 않기 때문에 발생하는 문제다.
  - 따라서 +를 부분(partial)함수라고 부른다.
- N에 대한 요구조건: half, odd, == 0, == 1