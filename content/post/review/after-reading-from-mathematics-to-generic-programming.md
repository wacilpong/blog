---
title: "After reading <from math to generic programming>"
date: "2020-12-30"
tags: ["review"]
draft: true
og_description: "알고리즘 산책을 읽고 내맘대로 정리해보았다."
---

by Alexander A. Stepanov, Daniel E. Rose

알고리즘 산책을 읽고 정리해놓고 싶은 것들을 적어놓는다.

<br />

#### 자연수의 합

- 삼각수는 첫 n개의 양의 정수를 나타내는 행들을 쌓아서 만들 수 있다.
- 직사각수는 삼각수에 n을 곱한다.
- 기하학적으로 직사각수는 n(n+1)이고, 이를 2로 나누면 삼각수가 된다.
- 따라서 1부터 자연수 n까지의 합은 n(n+1)/2가 된다.

<br />

- 자신을 제외한 모든 약수의 합이 자신과 같으면 완전수이다.

<br />

#### 유클리드 호제법

- 유클리드는 최소한의 단계로 최대한 다양하게 응용될 수 있는 결과를 이끄는 증명을 선호했다.
- 최대공측도(최대공약수) 구하기
  ```txt
  명제: 두 개의 서로 다른 양이 있을 때 더 작은 양을 더 큰 양에서 빼는 작업을 반복한 후에 남는 양이 그전 양을 측정할 수 없으면 두 양은 통분 불가능하다
  ```
  - 피타고라스 학파의 "최대공측도를 계산하는 절차가 영원히 종료되지 않으면 두 수 사이에는 최대공측도가 존재하지 않는다"는 결과와 같다.
  - `측도`는 선분 P,V가 있을 때 V를 유한 번 이어서 P를 표현할 수 있으면 V를 P의 측도라고 부른다.
  - `공측도`는 선분 P의 측도이면서 동시에 선분 V의 측도인 경우이다.
  - `최대공측도`는 공측도는 여러 개 있을 수 있는데, 그중 가장 큰 공측도이다.
  - 이는 추후 최대공약수와 같다.
  - **위 명제에 따라 계속 큰 쪽에서 작은 쪽을 빼는 방법이 유클리드 호제법이다.**
  - a와 b는 무한하지 않기 때문에 나눈 나머지를 재귀적으로 비교할 수 있다.
  - 이는 a와 b에 대해서 a <= nb를 만족하는 자연수 n이 존재한다는 `아르키메데스의 공리`로 증명된다.
    ```c++
    integer gcd(integer a, integer b) {
        while (b != interger(0)) {
            a = a % b;
            std::swap(a, b);
        }

        return a;
    }
    ```
  - 위 코드의 순환이 돌 때마다 최대공약수는 항상 같아야 한다.
  - 따라서 gcd(a0, b0) = gcd(b0, r1) = gcd(r1, r2) = ... = gcd(rn-1, rn)
  - **rn-1과 rn의 나머지는 종료 조건에 따라 0이므로 gcd(a0, b0) = ... = gcd(rn, 0) = rn**
  - 자바스크립트 재귀적 순환으로 최대공약수를 구할 경우 다음과 같다.
    ```js
      function gcd(a, b){
          const r = a % b;

          if (r > 0) {
            return gcd(b, r);
          }

          return b;
      }
    ```