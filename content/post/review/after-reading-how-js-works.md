---
title: "After reading how js works, by Douglas Crockford"
date: "2020-10-06"
tags: ["review"]
draft: false
og_description: "자바스크립트는 왜 이 모양일까를 읽고 내맘대로 정리해보았다."
---

## 시작하기 전에
- 자바스크립트는 이상한 corner case와 edge case로 가득 차 있다.
  - `corner case`: 에상하지 못한 환경이나 입력 데이터 등으로 인해 프로그램에 문제가 발생하는 경우, 문제가 발생하는 환경을 동일하게 재현하기 어려워 디버그하기 힘듬
  - `edge case`: 데이터가 기대하는 범위의 최소 또는 최댓값일 때 프로그램에 문제가 발생하는 경우, 오버플로 or 언더플로
- 절대 코너 케이스와 엣지 케이스를 가까이하지 말라.
  - 언어의 간결하고 분명한 부분만으로도 좋은 프로그램을 만들 수 있다.
  - _가끔 언어의 모호한 면을 파고들곤 하는데, 이걸 굳이 프로그램에서 사용할 필요는 없을듯?_

<br />
<hr />

## 숫자
- js는 int형을 사용하지 않으므로 오버플로 문제가 발생하지 않는다.
- 오버플로가 발생하지 않기 때문에 자바스크립트의 정수는 훨씬 안정적이다.
- js의 number는 자바의 double과 밀접하게 64비트 2진 부동소수점 타입이다.
- js에는 **18437736874454810627개** 의 불변 숫자 객체가 내장되어 있는데, 각각은 고유한 숫자를 나타낸다.
- 숫자 리터럴은 각 리터럴의 값과 가장 잘 맞는 숫자 객체에 대한 참조를 생성한다.
- `NaN` 는 문자열을 숫자로 변환하려고 했으나 실패했을 때 결과값으로 반환될 수 있다.
- typeof 연산자는 **NaN** 를 number형이라고 표시해서 아주 헷갈린다.
- `Number.prototype` 은 모든 수가 상속하는 객체이다.
- `더하기 부호(+)`는 만약 한 피연산자가 문자열이면, 이 연산자는 나머지 피연산자를 문자열로 바꾸고 연결한다.
- js를 비롯한 많은 언어가 2진 부동소수점을 사용하기 때문에 0.1 + 0.2를 정확히 계산하지 못한다.
- 10진 소수점을 처리하는 단일 숫자 시스템이 나오기 전까지는 안전한 정수 범위에서 작업하자.
- js가 차용한 IEEE754 규격은 부동소수점 수의 밑수로 2를 사용한다.
- 1950년대 하드웨어는 밑수가 2인 부동소수점 시스템과 잘 맞았으나, **무어의 법칙** 덕분에 이제는 상관없다.
- js 자체의 능력을 활용하면 되므로, 새로운 숫자형을 추가할 필요는 없다.

<br />
<hr />

## Boolean
- 불이 제대로 쓰이는 위치는 if조건문, !피연산자 등이다.
- 잘 설계된 언어라면 해당 위치들에 오직 불 값만 사용하도록 하지만, js는 여기에 아무 값이나 사용해도 된다.
- **불인 척하는** 자료형에 속한 값은 truthy이거나 falsy 둘 중 하나이다.
- `falsy`: **false, null, undefined, 빈 문자열(""), 0, NaN**
- `truthy`: **"false"나 "0"같은 문자열도 포함된다.**

<br />
<hr />

## 배열
- 배열은 객체 리터럴이 아닌 배열 리터럴을 사용해 만들어진다.
- typeof 연산자는 배열에 대해 **object** 를 반환하므로 `Array.isArray`를 사용해 체크하자.
- 최근 배열 요소를 한번에 하나씩 처리하기보다, 배열을 좀 더 함수처럼 처리해야 한다는 생각이 더 지배적이다.
- **shift와 unshift 메서드는 pop과 push에 비해 느린데, 배열이 크면 특히 심해진다.**
- `reduce` 메서드는 배열을 하나의 값으로 축약하며, 초기 축약값을 전달하지 않으면 0번째 배열 요소가 초기 축약값이다. _축약이라고 생각하니 reduce 명칭이 더 와닿는듯._
- `forEach` 메서드는 배열의 모든 요소에 대해 전달된 함수를 호출한다.
- **forEach나 find는 배열의 끝에 도달하기 전에 종료할 수 있지만, map, reduce, filter는 아니다.**
- `sort` 메서드는 추가 메모리 공간을 사용하지 않고 배열 자체를 수정하므로 공유 중인 배열을 정렬하면 위험하다.

<br />
<hr />

## 객체
- 객체에 찾을 수 없는 속성 값을 요청하면, 객체는 undefined라는 빈 값을 반환한다.
- 존재하지 않거나 빼먹은 속성 값을 요청하는 것은 에러가 아니므로, 이는 정상적인 동작이다.
- js 객체에서 오로지 null과 undefined만이 빈 값(bottom value)이다.
- `Object.create(prototype)`은 이미 있는 객체를 받아 이를 상속받는 새로운 객체를 반환한다. 즉, 기존의 객체가 새로운 객체의 ptorotype이 된다.
- Object.create(null)을 쓰면 객체가 아무것도 상속받지 못하게 만들 수 있다.
- **객체의 속성에 값을 대입하면 가장 새로운 객체, 즉 프로토타입 체인의 가장 위쪽에 있는 객체만 변경된다.**
- `WeakMap`은 문자열을 제외한 다른 객체를 키로 쓰고, 존재하는 키의 사본이 없다면 해당 키의 속성은 자동으로 삭제되기 때문에 js의 가비지 컬렉터와 잘 맞는다.

<br />
<hr />

## 문자열
- 문자열은 0에서 65535 사이의 크기를 가지는 부호가 없는 16비트 정수로 이루어진 불변 배열이다.
- 문자열은 일반 배열과 다르게 항상 동결된 상태이고 **===** 연산자에 의해 동등하게 검사할 수 있다.
- 템플릿 문자열 리터럴은 여러 줄에 걸쳐 쓸 수 있는 문자열 리터럴이며, **백틱(`)** 을 사용한다.
- 템플릿 문자열 리터럴은 `interpoloation(${})`을 제공하는데 이는 XSS같은 보안에 취약하다.
- 템플릿 문자열 리터럴을 함수로 전달해서 인코딩 후 조립해서 반환하면 어느정도 위험을 완화할 수는 있다.

<br />
<hr />

## Statement
- function문은 세미콜론으로 끝나지 않지만, let문과 선언문은 세미콜론으로 끝난다.
- **function 선언문은 호이스팅되므로 함수 몸체나 모듈 안에 두는 것은 괜찮지만, if나 switch 등에 두는 것은 좋지 않다.**
- `const`는 상수의 줄임말이지만, 함수의 실행이 끝나면 사라질 수도 있는 임시적인 거고 프로그램이 실행될 때나 함수가 호출될 때마다 다른 값을 가질 수도 있다.
- js는 조건문이 '불인 척하는 값'이길 기대하지만, 개발할 때는 정확한 불 값으로 처리하자.
- 반복문을 만드는 가장 좋은 방법은 꼬리재귀(tail recursion)을 사용하는 것이다.
- js에는 **break, continue, throw, return 4가지 중단문이 있는데 이들은 모두 goto가 아니다.** (_그러니 안심하자!_)

<br />
<hr />

## 함수
- 최초의 프로그램은 루틴이라고 불렸고, 같은 루틴을 서브루틴으로 만들었다.
- 유용한 여러 서브루틴을 묶어서 라이브러리라고 부르기 시작했다. 
- 확산 연산자(...)를 인자 목록에서 쓰면 전개(spread)문라고 부르고, 매개변수 목록에서 쓰면 나머지(rest)문이 된다.
  ```js
  // rest
  function func(...args) {
    return args;
  }

  // spread
  func(...a);
  ```
- 함수가 호출되면 활성 객체(activation object)가 만들어진다.
- **js는 활성 객체를 다른 객체와 마찬가지로 힙에 저장하고 가비지 컬렉터에 의해 처리된다.**
- 함수 실행 코드뿐 아니라 함수 객체가 생성되는 시점에 활성화된 활성 객체에 대한 참조가 있기 때문에 클로저를 사용할 수 있다.
- 함수 객체가 외부 함수에 대한 활성 객체의 참조를 가지는 방식을 `클로저`라고 한다.

<br />
<hr />

## 예외
- js는 throw에 어떤 값이든 허용하므로 아무거나 '던져도' 된다.
- 함수의 모든 문장은 제각각 try ~ catch를 가질 수 있다.
- 하나의 함수에서 try를 두번 이상 쓰지 않도록 주의해야 한다.
- **throw문이 실행되면 현재 함수에 대한 캐치맵을 참조하며, 지정된 catch절이 있으면 제어권을 얻어 실행된다. catch절이 없으면 함수를 호출한 곳을 찾아 여기가 새로운 위치가 된다.**
- 이 과정을 반복해서 catch절을 찾을 때까지 가상의 호출 스택을 타고 내려간다.
- 호출 스택이 더 이상 없으면 `처리할 수 없는 예외(uncaught exception)` 가 된다.

<br />
<hr />

(... 15장 프로그램 ing)