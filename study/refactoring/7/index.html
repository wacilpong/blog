<!DOCTYPE html>
<html lang="kr-ko">
    <head>
        <meta name="description" content="" />

<meta name="og:type" content="website" />
<meta property="og:title" content="refactoring 7: Encapsulation" />
<meta property="og:site_name" content="refactoring 7: Encapsulation" />
<meta property="og:description" content="" />
<meta property="og:url" content="https://wacilpong.github.io/blog/study/refactoring/7/" />

<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="refactoring 7: Encapsulation" />
<meta name="twitter:description" content="" />

<meta property="og:image" content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512" />
<meta
  property="twitter:image:src"
  content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512"
/>


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-171393148-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());

  gtag("config", "UA-171393148-1");
</script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>refactoring 7: Encapsulation</title>
        
            <link rel="icon" href="https://wacilpong.github.io/blog/favicon.ico">
        
        <style>

    html body {
        font-family: 'Raleway', sans-serif;
        background-color: white;
    }

    :root {
        --accent: #469160;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://wacilpong.github.io/blog/css/main.css">


 <link rel="stylesheet" href="https://wacilpong.github.io/blog/css/custom.css"> 


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.73.0" />
        

        

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">refactoring 7: Encapsulation</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/blog/">Home</a></li>
                            
                                <li><a href="/blog/tags/">Category</a></li>
                            
                                <li><a href="/blog/post/">Posts</a></li>
                            
                                <li><a href="/blog/study/">Study</a></li>
                            
                                <li><a href="/blog/learned/">What I Learned</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wacilpong/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/areum-han-a10645118/"><i class="fa fa-linkedin"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2>refactoring 7: Encapsulation</h2>
        <h5>캡슐화</h5>
        

    </div>

    <div align="start" class="content"><h3 id="시작하며">시작하며</h3>
<ul>
<li>각 모듈이 드러내지 않아야 할 비밀을 얼마나 잘 숨기느냐 ⇒ 모듈을 분리하는 가장 중요한 기준</li>
<li>클래스는 본래 정보를 숨기는 용도로 설계되었다.</li>
<li>클래스는 내부 정보뿐 아니라 클래스 사이의 연결 관계를 숨기는 데도 유용하다.</li>
<li>함수 또한 구현을 캡슐화한다.</li>
</ul>
<p><br /></p>
<h3 id="71-레코드-캡슐화하기-encapsulate-record">7.1 레코드 캡슐화하기 Encapsulate Record</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// **AS-IS: 레코드(객체 리터럴)**
</span><span style="color:#75715e"></span><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">organization</span> <span style="color:#f92672">=</span> { <span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;루미&#34;</span>, <span style="color:#a6e22e">country</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;KR&#34;</span> };

<span style="color:#75715e">// **TO-BE: 클래스(책에서 말하는 &#39;객체&#39; 예시)**
</span><span style="color:#75715e">// 레코드를 캡슐화하는 목적은 변수 자체는 물론, 내용을 조작하는 방식도 통제하기 위함
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Organization</span> {
  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">data</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">name</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_country</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">data</span>.<span style="color:#a6e22e">country</span>;
  }

  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">name</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_name</span>;
  }
  <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">name</span>(<span style="color:#a6e22e">arg</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_name</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">arg</span>;
  }
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">country</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_country</span>;
  }
  <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">country</span>(<span style="color:#a6e22e">arg</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_country</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">arg</span>;
  }
}
</code></pre></div><ul>
<li>객체는 어떻게 저장했는지 숨긴 채 값들을 각각의 메서드로 제공할 수 있다.</li>
<li>가변 데이터는 객체로 저장하고, 값이 불변이면 레코드에 저장한다.</li>
<li>레코드는 연관된 여러 데이터를 직관적으로 묶을 수 있다.
<ul>
<li>ex. 필드이름 노출하는 경우: <code>{name: ‘루미’, country: ‘KR’}</code></li>
<li>ex. 필드이름 숨긴 경우: <code>new Map(…)</code> ⇒ 길이 등을 직접 확인해야 한다.</li>
</ul>
</li>
</ul>
<hr />
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// **AS-IS: 중첩된 레코드**
</span><span style="color:#75715e">// 중첩 정도가 심할수록 체이닝이 심해진다.
</span><span style="color:#75715e">// data[id].usages[year][month]...
</span><span style="color:#75715e"></span><span style="color:#e6db74">&#39;1994&#39;</span><span style="color:#f92672">:</span> {
	<span style="color:#a6e22e">name</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#39;루미&#39;</span>,
	<span style="color:#a6e22e">usages</span><span style="color:#f92672">:</span> {
		<span style="color:#e6db74">&#39;2016&#39;</span><span style="color:#f92672">:</span> {
			<span style="color:#e6db74">&#39;1&#39;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">50</span>,
			<span style="color:#e6db74">&#39;2&#39;</span><span style="color:#f92672">:</span> <span style="color:#ae81ff">55</span>
		}
	}
},
...

<span style="color:#75715e">// **TO-BE:**
</span><span style="color:#75715e">// 아래에서 rawData 메서드를 통해 내부 데이터를 복제해 사용하므로,
</span><span style="color:#75715e">// 사용하는 개발자(클라이언트)가 데이터를 직접 수정할 수는 없게 된다.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">CustomerData</span> {
	<span style="color:#a6e22e">get</span> <span style="color:#a6e22e">rawData</span>() {
		<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">_</span>.<span style="color:#a6e22e">cloneDeep</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_data</span>);
	}

	<span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">data</span>) {
		<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_data</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">data</span>;
	}
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getCustomerData</span>() {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">customerData</span>;
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">getRawDataOfCustomers</span>() {
	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">customerData</span>.<span style="color:#a6e22e">rawData</span>;
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">setRawDataOfCustomers</span>(<span style="color:#a6e22e">arg</span>) {
	<span style="color:#a6e22e">customerData</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">CustomerData</span>(<span style="color:#a6e22e">arg</span>);
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">compareUsage</span>(<span style="color:#a6e22e">id</span>, <span style="color:#a6e22e">year</span>, <span style="color:#a6e22e">month</span>) {
	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">later</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getCustomerData</span>().<span style="color:#a6e22e">rawData</span>[<span style="color:#a6e22e">id</span>].<span style="color:#a6e22e">usages</span>[<span style="color:#a6e22e">year</span>][<span style="color:#a6e22e">month</span>];
	<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">earlier</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">getCustomerData</span>().<span style="color:#a6e22e">rawData</span>[<span style="color:#a6e22e">id</span>].<span style="color:#a6e22e">usages</span>[<span style="color:#a6e22e">year</span> <span style="color:#f92672">-</span> <span style="color:#ae81ff">1</span>][<span style="color:#a6e22e">month</span>];

	<span style="color:#66d9ef">return</span> {
		<span style="color:#a6e22e">laterAmount</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">later</span>,
		<span style="color:#a6e22e">change</span><span style="color:#f92672">:</span> <span style="color:#a6e22e">later</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">earlier</span>
	};
}
</code></pre></div><ul>
<li>
<p>위 TO-BE는 데이터 구조가 클수록 복제 비용이 커져 성능이 느려질 수도 있고, 클라이언트가 원본을 수정한다고 착각할 수 있다.</p>
<ul>
<li>
<p>해결방법: 읽기전용 프락시를 제공하기</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#66d9ef">const</span> <span style="color:#a6e22e">target</span> <span style="color:#f92672">=</span> {
  <span style="color:#a6e22e">message1</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;hello&#34;</span>,
  <span style="color:#a6e22e">message2</span><span style="color:#f92672">:</span> <span style="color:#e6db74">&#34;everyone&#34;</span>,
};

<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">handler1</span> <span style="color:#f92672">=</span> {};
<span style="color:#66d9ef">const</span> <span style="color:#a6e22e">proxy1</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> Proxy(<span style="color:#a6e22e">target</span>, <span style="color:#a6e22e">handler1</span>);
</code></pre></div></li>
<li>
<p>새로운 방법: 레코드 캡슐화를 재귀적으로 하기</p>
<ul>
<li><a href="http://martinfowler.com/articles/refactoring-document-load.html">http://martinfowler.com/articles/refactoring-document-load.html</a></li>
<li>이 방법도 데이터 구조가 거대하면 일이 커진다.</li>
<li>그 데이터 구조를 사용할 일이 많지 않으면 효과도 별로 없다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br /></p>
<aside>
💡 루미의견❓
<p>레코드를 캡슐화하는 가장 큰 이유가 직접 수정하지 못하게 만드는 거라면, 그냥 객체(레코드)를 직접 수정하지 못하게 freeze()하고 사용하는 게 더 깔끔할 것 같다.</p>
<p>위 예시는 아주 큰 레코드에 한해서 클래스로 빼서 캡슐화하는 게 좋다고 생각한다.</p>
</aside>
<hr />
<h3 id="72-컬렉션-캡슐화하기-encapsulate-collection">7.2 컬렉션 캡슐화하기 Encapsulate Collection</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// AS-IS:
</span><span style="color:#75715e">// getter가 컬렉션 자체를 반환하기 때문에
</span><span style="color:#75715e">// 클래스가 눈치채지 못한 상태에서 컬렉션의 원소들이 바뀔 수 있다.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
	<span style="color:#a6e22e">get</span> <span style="color:#a6e22e">courses</span>() { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_courses</span>; }
	<span style="color:#a6e22e">set</span> <span style="color:#a6e22e">courses</span>(<span style="color:#a6e22e">list</span>) { <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_courses</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">list</span>; }
}

<span style="color:#75715e">// TO-BE:
</span><span style="color:#75715e">// getter가 컬렉션의 복제본을 만들어 반환한다.
</span><span style="color:#75715e">// 컬렉션을 소유한 클래스를 통해서만 원소를 변경하게 만들 수 있다.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
	<span style="color:#a6e22e">get</span> <span style="color:#a6e22e">courses</span>() { <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_courses</span>.<span style="color:#a6e22e">slice</span>(); }
	<span style="color:#a6e22e">addCourse</span>(<span style="color:#a6e22e">course</span>) { ... }
	<span style="color:#a6e22e">removeCourse</span>(<span style="color:#a6e22e">course</span>) { ... }
}
</code></pre></div><ul>
<li>내부 컬렉션의 복제본을 반환하는 방식은 널리 알려져 있다.</li>
<li>컬렉션이 상당히 크면 성능 문제가 발생할 수 있지만, 그런 경우는 거의 없다.</li>
<li>저자의 경험에 따르면 컬렉션은 어느정도 강박증을 갖고 불필요한 복제본을 만드는 편이, 예상치 못한 오류들을 디버깅하는 것보다 낫다고 한다.<br />
<em>다른 언어와 달리 자바스크립트는 배열을 정렬할 때 원본을 수정하기 때문!</em></li>
</ul>
<p><br /></p>
<aside>
💡 루미의견❓
<p>상태를 불변하게 유지하는 것은 꽤 전부터 모던 웹개발에서의 트렌드이다. 특히 Virtual DOM방식으로 상태 변화를 일으키는 리액트에 의해 프론트엔드 개발자들에게 익숙해진 것 같다. 내부에서 객체 형태(Fiber)로 바뀐 주소값만 체크하기 때문에, 원본을 바꾸면 렌더링이 일어나지 않을 수 있기 때문이다.</p>
<p>이러한 상태 변화를 감지하는 기법은 redux도 마찬가지인데, 당장 앵귤러의 ngrx의 reducer만 보더라도 원본 상태를 수정하면 기존 주소값은 유지된 채 값만 바뀌는 것이어서 store가 바뀌지 않는다.</p>
<p>원본을 바꾸면 기대하지 않은 동작이 발생하기 쉽다. 그리고 객체를 deep copy 방식으로 통째로 비교하면 비용이 상당히 든다. 따라서 최근 프론트엔드 개발 도구도 그렇고, 책의 저자도 그냥 객체의 복제본을 다시 생성해 그 객체의 주소값을 새로이 부여하는 편이 낫다고 말하는 것일듯.</p>
</aside>
<hr />
<h3 id="73-기본형을-객체로-바꾸기-replace-primitive-with-query">7.3 기본형을 객체로 바꾸기 Replace Primitive with Query</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// AS-IS:
</span><span style="color:#75715e"></span><span style="color:#a6e22e">orders</span>.<span style="color:#a6e22e">filter</span>((<span style="color:#a6e22e">o</span>) =&gt; <span style="color:#e6db74">&#34;high&#34;</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">priority</span> <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34;rush&#34;</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">priority</span>).<span style="color:#a6e22e">length</span>;

<span style="color:#75715e">// TO-BE:
</span><span style="color:#75715e">// Order를 통해서 Priority 객체를 제공받도록 해서 Priority를 직접 건드리지 않는다.
</span><span style="color:#75715e">// 우선순위 값들 또한 Priority의 메서드로만 조작해 반환하도록 한다.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">orders</span>.<span style="color:#a6e22e">filter</span>((<span style="color:#a6e22e">o</span>) =&gt; <span style="color:#a6e22e">o</span>.<span style="color:#a6e22e">priority</span>.<span style="color:#a6e22e">higherThan</span>(<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Priority</span>(<span style="color:#e6db74">&#34;normal&#34;</span>))).<span style="color:#a6e22e">length</span>;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Order</span> {
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">priority</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_priority</span>;
  }
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">priorityString</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_priority</span>.<span style="color:#a6e22e">toString</span>();
  }
  <span style="color:#a6e22e">set</span> <span style="color:#a6e22e">priority</span>(<span style="color:#a6e22e">string</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_priority</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Priority</span>(<span style="color:#a6e22e">string</span>);
  }
}

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Priority</span> {
  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">value</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">value</span> <span style="color:#66d9ef">instanceof</span> <span style="color:#a6e22e">Priority</span>) <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">value</span>;
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">value</span>;
  }

  <span style="color:#a6e22e">toString</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_value</span>;
  }
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">_index</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">Priority</span>.<span style="color:#a6e22e">legalValues</span>().<span style="color:#a6e22e">findIndex</span>((<span style="color:#a6e22e">s</span>) =&gt; <span style="color:#a6e22e">s</span> <span style="color:#f92672">===</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_value</span>);
  }
  <span style="color:#66d9ef">static</span> <span style="color:#a6e22e">legalValues</span>() {
    <span style="color:#66d9ef">return</span> [<span style="color:#e6db74">&#34;low&#34;</span>, <span style="color:#e6db74">&#34;normal&#34;</span>, <span style="color:#e6db74">&#34;high&#34;</span>, <span style="color:#e6db74">&#34;rush&#34;</span>];
  }
  <span style="color:#a6e22e">equals</span>(<span style="color:#a6e22e">other</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_index</span> <span style="color:#f92672">===</span> <span style="color:#a6e22e">other</span>.<span style="color:#a6e22e">_index</span>;
  }
  <span style="color:#a6e22e">higherThan</span>(<span style="color:#a6e22e">other</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_index</span> <span style="color:#f92672">&gt;</span> <span style="color:#a6e22e">other</span>.<span style="color:#a6e22e">_index</span>;
  }
  <span style="color:#a6e22e">lowerThan</span>(<span style="color:#a6e22e">other</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_index</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">other</span>.<span style="color:#a6e22e">_index</span>;
  }
}
</code></pre></div><ul>
<li>기본형으로 간단히 표현했던 정보들이 개발 도중 간단하지 않게 변할 수 있다.<br />
<em>ex. 전화번호를 문자열로 표현했는데 추후 포매팅이나 지역 코드 추출 같은 특별한 동작이 필요해짐</em></li>
<li>이런 로직들로 금세 중복 코드가 늘어나서 사용할 때마다 드는 노력도 늘어나게 된다.</li>
<li>저자는 단순 출력 이상의 기능이 필요해지는 순간 전용 클래스를 정의하는 편이라고 한다.</li>
</ul>
<p><br /></p>
<aside>
💡 루미의견❓
<p>기본형으로 쓴 데이터들 중에서 얼마나 많은 데이터들이 위와 같은 리팩터링이 필요하게 될 정도로 커질지 의문이다. 차라리 숫자, 문자를 바로 쓰지 않고 상수화하여 쓰는 식으로만 1차 리팩터링을 해도 좋지 않을까?</p>
<p>커질 소지가 분명한 정보들(거래소 코드를 조합해 다양한 상태를 만든다거나, 상품옵션 조작하기 등 N개의 경우의 수가 생길만한)이 아니라면 일단 기본형과 객체리터럴 정도로만 갖고 있는 편이 낫지 않을까?</p>
</aside>
<hr />
<h3 id="74-임시-변수를-질의-함수로-바꾸기-replace-temp-with-query">7.4 임시 변수를 질의 함수로 바꾸기 Replace Temp with Query</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// (Order class 내부)
</span><span style="color:#75715e"></span>
<span style="color:#75715e">// AS-IS:
</span><span style="color:#75715e">// 여기서 임시 변수는 basePrice와 discountFactor이다.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">get</span> <span style="color:#a6e22e">price</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">basePrice</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_quantity</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_item</span>.<span style="color:#a6e22e">price</span>;
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">discountFactor</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.98</span>;

	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">basePrice</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1000</span>) <span style="color:#a6e22e">discountFactor</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">0.03</span>;

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">basePrice</span> <span style="color:#f92672">*</span> <span style="color:#a6e22e">discountFactor</span>;
}

<span style="color:#75715e">// TO-BE:
</span><span style="color:#75715e">// 이제 다른 곳에서도 basePrice, discountFactor를 사용할 수 있다.
</span><span style="color:#75715e"></span><span style="color:#a6e22e">get</span> <span style="color:#a6e22e">basePrice</span>() {
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_quantity</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_item</span>.<span style="color:#a6e22e">price</span>;
}

<span style="color:#a6e22e">get</span> <span style="color:#a6e22e">discountFactor</span>() {
	<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">discountFactor</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.98</span>;

	<span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">basePrice</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">1000</span>) <span style="color:#a6e22e">discountFactor</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">0.03</span>;

	<span style="color:#66d9ef">return</span> <span style="color:#a6e22e">discountFactor</span>;
}

<span style="color:#a6e22e">get</span> <span style="color:#a6e22e">price</span>() {
	<span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">basePrice</span> <span style="color:#f92672">*</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">discountFactor</span>;
}
</code></pre></div><ul>
<li>함수 안에서 어떤 코드의 결과를 다시 참조할 목적으로 임시 변수를 쓰기도 한다.</li>
<li>그러나 한 걸음 나아가 아예 함수로 만들어 사용하는 편이 나을 때가 많다.</li>
<li>변수 대신 함수로 만들면 비슷한 계산을 수행하는 다른 함수에서도 사용할 수 있어 코드 중복이 줄어든다.</li>
<li>특히 클래스 안에서 적용할 때 효과가 큰데, 클래스는 추출할 메서드들에 공유 컨텍스트를 제공하기 때문이다.</li>
<li><strong>변수에 값을 한 번 대입한 후, 더 복잡한 코드에서 여러 번 다시 대입하고, 변수가 다음번에 사용될 때 수행해도 똑같은 결과를 내야 할 때</strong>만 유효한 리팩터링 기법이다.</li>
</ul>
<hr />
<h3 id="75-클래스-추출하기-extract-class">7.5 클래스 추출하기 Extract Class</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// AS-IS:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">officeAreaCode</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_officeAreaCode</span>;
  }
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">officeNumber</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_officeNumber</span>;
  }
}

<span style="color:#75715e">// TO-BE:
</span><span style="color:#75715e">// 이제 전화번호를 회사 뿐만 아니라 다른 곳에서도 사용할 수 있다.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">officeAreaCode</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_telephoneNumber</span>.<span style="color:#a6e22e">areaCode</span>;
  }
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">officeNumber</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_telephoneNumber</span>.<span style="color:#a6e22e">number</span>;
  }
}
<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">TelephoneNumber</span> {
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">areaCode</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_areaCode</span>;
  }
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">number</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_number</span>;
  }
}
</code></pre></div><ul>
<li>메서드와 데이터가 너무 많은 클래스는 이해하기 쉽지않으니 적절히 분리하는 것이 좋다.</li>
<li>언제 클래스를 추출해야 할까요?<br />
⇒ 특정 데이터/메서드 일부를 제거했을 때 다른 곳에서 논리적으로 문제가 없다면 분리할 수 있다는 뜻. - 일부 데이터와 메서드를 따로 묶을 수 있을 때 - 함께 변경되는 일이 많거나 서로 의존하는 데이터들일 때</li>
</ul>
<hr />
<h3 id="76-클래스-인라인하기-inline-class">7.6 클래스 인라인하기 Inline Class</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// AS-IS:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">officeAreaCode</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_telephoneNumber</span>.<span style="color:#a6e22e">areaCode</span>;
  }
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">officeNumber</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_telephoneNumber</span>.<span style="color:#a6e22e">number</span>;
  }
}

<span style="color:#75715e">// TO-BE:
</span><span style="color:#75715e">// telephoneNumber를 회사번호로만 사용하고 있다면 아래처럼 합치는 편이 낫다.
</span><span style="color:#75715e"></span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">officeAreaCode</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_officeAreaCode</span>;
  }
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">officeNumber</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">_officeNumber</span>;
  }
}
</code></pre></div><ul>
<li>클래스 인라인하기는 클래스 추출하기를 거꾸로 돌리는 리팩터링 기법이다.</li>
<li>언제 클래스를 인라인해야 할까요?
<ul>
<li>특정 클래스가 더 이상 제 역할을 하지 못할 때 많이 사용하는 클래스로 흡수시킨다.</li>
<li>두 클래스 기능을 지금과 다르게 배분하고 싶을 때<br />
(한 컨텍스트의 요소들을 다른 쪽으로 하나씩 옮겨 인라인한 후 추출하여 다시 분리)</li>
</ul>
</li>
</ul>
<hr />
<h3 id="77-위임-숨기기-hide-delegate">7.7 위임 숨기기 Hide Delegate</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// AS-IS:
</span><span style="color:#75715e"></span><span style="color:#a6e22e">manager</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">aPerson</span>.<span style="color:#a6e22e">department</span>.<span style="color:#a6e22e">manager</span>;

<span style="color:#75715e">// TO-BE:
</span><span style="color:#75715e"></span><span style="color:#a6e22e">manager</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">aPerson</span>.<span style="color:#a6e22e">manager</span>;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">manager</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">department</span>.<span style="color:#a6e22e">manager</span>;
  }
}
</code></pre></div><ul>
<li>서버 객체의 필드가 가리키는 객체(위임 객체)의 메서드를 호출하려면 클라이언트는 이 객체를 알아야 한다.</li>
<li>위임 객체의 인터페이스가 바뀌면 이 인터페이스를 사용하는 모든 클라이언트가 코드를 수정해야 한다.</li>
<li><strong>이 의존성을 없애려면 서버 자체에 위임 메서드를 만들어서 위임 객체의 존재를 숨기면 된다.</strong></li>
<li>그러면 위임 객체가 수정되어도 서버 코드만 고치면 된다.</li>
</ul>
<p><br /></p>
<aside>
💡 루미의견❓
<p>분리해서 받으면 더 관리하기 수월할 것 같은 api 구조가 있다. 위 예시처럼 ‘부서’와 ‘사원’에 대한 api 응답 객체가 분리되어 있어야 각각의 응답 객체를 여러 곳에서 사용할 수 있을 것이다.</p>
<p>실무에서도 가끔 서버에서 api를 주면 별 생각 없이 쓸 때도 있는데,</p>
<p>(1) 이때 특정 필드가 다른 비즈니스 로직에도 엮여서 여러 번 쓰여야 하는지,<br />
(2) 다른 필드에 의존하고 있어서 그 필드가 바뀌면 수정될 여지가 있는지 (위임 객체인지)</p>
<p>잘 파악해야겠다.</p>
</aside>
<hr />
<h3 id="78-중개자-제거하기-remove-middle-man">7.8 중개자 제거하기 Remove Middle Man</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// AS-IS:
</span><span style="color:#75715e"></span><span style="color:#a6e22e">manager</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">aPerson</span>.<span style="color:#a6e22e">manager</span>;

<span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Person</span> {
  <span style="color:#a6e22e">get</span> <span style="color:#a6e22e">manager</span>() {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">department</span>.<span style="color:#a6e22e">manager</span>;
  }
}

<span style="color:#75715e">// TO-BE:
</span><span style="color:#75715e"></span><span style="color:#a6e22e">manager</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">aPerson</span>.<span style="color:#a6e22e">department</span>.<span style="color:#a6e22e">manager</span>;
</code></pre></div><ul>
<li>위임 객체를 캡슐화하면 7.7절과 같은 이점이 있으나, 적절하지 못할 때도 있다.</li>
<li>클라이언트가 위임 객체의 다른 기능을 사용할 때마다 서버에 위임 메서드를 추가해야 하기 때문이다.</li>
<li>그러면 서버 클래스는 단순히 전달만 하는 메서드가 많아져서 그저 중개자 역할로 전락한다.</li>
<li>이때는 클라이언트가 위임 객체를 직접 호출하는 편이 낫다.</li>
<li>이처럼 언제든지 필요하면 균형점을 옮겨 위임을 숨기거나 중개자를 제거하자.</li>
</ul>
<p><br /></p>
<aside>
💡 루미의견❓
<p>여기서는 모두 서버와의 예시를 들었지만, 프론트단에서도 유효한 리팩터링 기법이라고 생각한다. 위 예시처럼 department가 늘 person에 포함되어야 한다면 차라리 두 객체를 데이터 뭉치로 들고다니는 편이 낫다.</p>
</aside>
<hr />
<h3 id="79-알고리즘-교체하기-substitue-algorithm">7.9 알고리즘 교체하기 Substitue Algorithm</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-jsx" data-lang="jsx"><span style="color:#75715e">// AS-IS:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foundPerson</span>(<span style="color:#a6e22e">people</span>) {
  <span style="color:#66d9ef">for</span> (<span style="color:#66d9ef">let</span> <span style="color:#a6e22e">i</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>; <span style="color:#a6e22e">i</span> <span style="color:#f92672">&lt;</span> <span style="color:#a6e22e">people</span>.<span style="color:#a6e22e">length</span>; <span style="color:#a6e22e">i</span><span style="color:#f92672">++</span>) {
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">people</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;dawn&#34;</span>) {
      <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;dawn&#34;</span>;
    }
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">people</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;daisy&#34;</span>) {
      <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;daisy&#34;</span>;
    }
    <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">people</span>[<span style="color:#a6e22e">i</span>] <span style="color:#f92672">===</span> <span style="color:#e6db74">&#34;lena&#34;</span>) {
      <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;lena&#34;</span>;
    }
  }

  <span style="color:#66d9ef">return</span> <span style="color:#e6db74">&#34;&#34;</span>;
}

<span style="color:#75715e">// TO-BE:
</span><span style="color:#75715e"></span><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">foundPerson</span>(<span style="color:#a6e22e">people</span>) {
  <span style="color:#66d9ef">const</span> <span style="color:#a6e22e">candidates</span> <span style="color:#f92672">=</span> [<span style="color:#e6db74">&#34;dawn&#34;</span>, <span style="color:#e6db74">&#34;daisy&#34;</span>, <span style="color:#e6db74">&#34;lena&#34;</span>];

  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">people</span>.<span style="color:#a6e22e">find</span>((<span style="color:#a6e22e">p</span>) =&gt; <span style="color:#a6e22e">candidates</span>.<span style="color:#a6e22e">includes</span>(<span style="color:#a6e22e">p</span>)) <span style="color:#f92672">||</span> <span style="color:#e6db74">&#34;&#34;</span>;
}
</code></pre></div><ul>
<li>어떤 목적을 달성하는 방법은 여러 가지가 있다.</li>
<li>하지만 때로는 알고리즘 전체를 걷어내고 훨씬 간결한 알고리즘으로 바꿔야 할 때가 있다.</li>
</ul>
<p><br /></p>
<p><strong>[절차]</strong></p>
<ol>
<li>
<p>교체할 코드를 함수 하나에 모은다.</p>
</li>
<li>
<p>이 함수만을 이용해 동작을 검증하는 테스트를 마련한다.</p>
</li>
<li>
<p>대체할 알고리즘을 준비한다.</p>
</li>
<li>
<p>정적 검사를 수행한다.<br />
<em>(컴파일 단계에서 타입 에러는 없는지 등을 확인하라는 뜻인듯)</em></p>
</li>
<li>
<p>기존과 새 알고리즘의 결과를 비교하는 테스트를 수행한다. 두 결과가 같다면 리팩터링이 끝난다. 그렇지 않다면 기존 알고리즘을 참고해서 새 알고리즘을 테스트하고 디버깅한다.</p>
</li>
</ol>
</div>

</main>

        <footer>
            <p class="copyright text-muted">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>.</p>
        </footer>

        

        
    </body>

</html>

