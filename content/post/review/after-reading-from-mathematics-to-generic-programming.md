---
title: "After reading <from math to generic programming>"
date: "2020-12-30"
tags: ["review"]
draft: true
og_description: "알고리즘 산책을 읽고 내맘대로 정리해보았다."
---

by Alexander A. Stepanov, Daniel E. Rose

알고리즘 산책을 읽고 정리해놓고 싶은 것들을 적어놓는다.

<br />

#### 자연수의 합

- 삼각수는 첫 n개의 양의 정수를 나타내는 행들을 쌓아서 만들 수 있다.
- 직사각수는 삼각수에 n을 곱한다.
- 기하학적으로 직사각수는 n(n+1)이고, 이를 2로 나누면 삼각수가 된다.
- 따라서 1부터 자연수 n까지의 합은 n(n+1)/2가 된다.

<br />

- 자신을 제외한 모든 약수의 합이 자신과 같으면 완전수이다.

<br />

#### 유클리드 호제법

- 유클리드는 최소한의 단계로 최대한 다양하게 응용될 수 있는 결과를 이끄는 증명을 선호했다.
- 최대공측도(최대공약수) 구하기
  ```txt
  명제: 두 개의 서로 다른 양이 있을 때 더 작은 양을 더 큰 양에서 빼는 작업을 반복한 후에 남는 양이 그전 양을 측정할 수 없으면 두 양은 통분 불가능하다
  ```
  - 피타고라스 학파의 "최대공측도를 계산하는 절차가 영원히 종료되지 않으면 두 수 사이에는 최대공측도가 존재하지 않는다"는 결과와 같다.
  - `측도`는 선분 P,V가 있을 때 V를 유한 번 이어서 P를 표현할 수 있으면 V를 P의 측도라고 부른다.
  - `공측도`는 선분 P의 측도이면서 동시에 선분 V의 측도인 경우이다.
  - `최대공측도`는 공측도는 여러 개 있을 수 있는데, 그중 가장 큰 공측도이다.
  - 이는 추후 최대공약수와 같다.
  - **위 명제에 따라 계속 큰 쪽에서 작은 쪽을 빼는 방법이 유클리드 호제법이다.**
  - a와 b는 무한하지 않기 때문에 나눈 나머지를 재귀적으로 비교할 수 있다.
  - 이는 a와 b에 대해서 a <= nb를 만족하는 자연수 n이 존재한다는 `아르키메데스의 공리`로 증명된다.
    ```c++
    integer gcd(integer a, integer b) {
        while (b != interger(0)) {
            a = a % b;
            std::swap(a, b);
        }

        return a;
    }
    ```
  - 위 코드의 순환이 돌 때마다 최대공약수는 항상 같아야 한다.
  - 따라서 gcd(a0, b0) = gcd(b0, r1) = gcd(r1, r2) = ... = gcd(rn-1, rn)
  - **rn-1과 rn의 나머지는 종료 조건에 따라 0이므로 gcd(a0, b0) = ... = gcd(rn, 0) = rn**
  - 자바스크립트 재귀적 순환으로 최대공약수를 구할 경우 다음과 같다.
    ```js
      function gcd(a, b){
          const r = a % b;

          if (r > 0) {
            return gcd(b, r);
          }

          return b;
      }
    ```

#### 완전수, 소수
- 완전수란 어떤 정수 n 자신을 제외한 모든 약수(진약수)의 합이 n인 수
- 2^n - 1은 완전수의 원천이 되는 소수의 형태이다.
- 1536년 후달리쿠스 레기우스는 n = 11이면 소수가 아님을 밝혔다.
- 프랑스 수학자 메르센은 n <= 257에서만 2^n - 1이 소수라고 주장했다.
- 이러한 주장으로 **2^n - 1은 메르센 소수라고 불리며, 요즘도 큰 소수에 사용된다.**
- 페르마는 2^2^n + 1 형태로 나오는 소수를 연구했으나, 첫 5개만 소수이고 더이상 페르마 소수가 존재하지 않을거라 예측하는 의견이 많다.
- **페르마의 작은 정리 : p가 소수이면 0 < a < p인 a에 대해 a^p-1 -1은 p로 나누어떨어진다.**
- 위 정리를 통해 오일러는 소수가 아닌 합성수에 적용되는 법칙을 연구했다.
- **오일러의 정리 : a와 n이 서로소일 때 a^φ(n) - 1은 n으로 나누어떨어진다.**
  - 이때 φ(n)은 오일러 파이 함수로, n과 서로소인 수의 개수를 구할 수 있다.
  - φ(n) = n * (1 - 1/p1) * (1 - 1/p2) ... * (1 - 1/pm)이며, pm은 n의 소인수
  - ex. φ(10) = 10 * (1 - 1/2) * (1 - 1/5) = 10 * 1/2 * 4/5 = 4개!!
- 완전수 연구는 실생활에 아무 쓸 데도 없지만 이를 통해 페르마의 작은 정리 발견으로 이어졌다.
- 오일러는 페르마의 작은 정리를 보며서 특별한 경우(소수)를 넘어 일반적인 경우(정수)로 확장했다.
- 제네릭 프로그래밍도 똑같은 추상화 과정을 거치게 된다.
- 코드를 일반화하는 일은 정리나 정리의 증명을 일반화하는 것과 마찬가지다.
