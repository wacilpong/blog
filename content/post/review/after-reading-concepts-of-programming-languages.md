---
title: "After reading concepts of programming languages, by Robert W. Sebesta"
date: "2020-06-28"
tags: ["review"]
draft: false
og_description: "프로그래밍 언어론을 읽고 내맘대로 정리해보았다."
---

프로그래밍 언어론을 읽고 내맘대로 정리해보았다. 비전공자로 학원도 없이 실무로 개발을 시작한 터라, computer science에 관한 지식이 부족한 것 같아서 읽기 시작했다. 알고 보니 전공책이라고 하더라.. 어쩐지 너무 어려웠다. 그리고 한글 번역이 정말 이상한 부분이 많아서 좀 검색하면서 읽었다.

<br />

**[기본적인 사항]**

- 프로그래밍 언어는 다음 세 가지 방법으로 구현(implementation)될 수 있다.

  - #### **Compiler implementation**
    - 컴퓨터에서 직접 실행될 수 있는 기계어로 번역될 수 있다.
    - 컴파일러가 번역하는 언어는 원시언어(source language)이다.
    - 컴파일 단계는 대체로 아래 순서를 거친다.
      - `원시 프로그램 -> 어휘 분석기 -> 구문 분석기 -> 중간 코드 생성기 -> 코드 생성기`
      - 컴파일러에서는 주석을 사용하지 않으므로, 어휘 분석기는 원시 프로그램에 포함된 주석을 무시한다.
      - 구문 분석기는 어휘들을 가져와 구문 구조를 표현한 **파스 트리**를 생성한다.
      - 중간 코드 생성기는 원시 프로그램과 컴파일러의 최종 출력인 기계어 프로그램 간의 중간 수준에 위치한다.
      - 코드 생성기는 프로그램의 최적화된 중간 코드 버전을 동등한 기계어 프로그램으로 변환한다.
  - #### **Pure interpretation**
    - 프로그램은 어떠한 번역 과정 없이 인터프리터에 의해 해석된다.
    - 원시 수준의 디버깅 연산을 쉽게 구현할 수 있다.
    - 그러나 고급 언어 문장을 해석(decode)해야 하므로, 컴파일된 시스템보다 10배 ~ 100배 실행 시간이 느리다.
    - 문장이 몇 번 실행되는지 상관없이, 그 문장을 매번 해석되어야 한다.
  - #### **Hybrid implementation system**
    - 고급 언어 프로그램을 용이한 해석이 가능하도록 설계된 중간 언어로 번역한다.
    - 따라서 원시 언어 문장을 한 번만 해석(decode)되므로 순수 해석보다 빠르다.
    - `Perl` 프로그램은 해석 전에 오류를 탐지하고 부분적으로 컴파일된다.
    - JIT(Just In Time) 방식은 프로그램을 중간 언어로 번역하고, 실행 중에 중간 언어 메소드가 호출되면 그 메소드를 기게 코드로 번역한다.

- 프로그래밍 언어의 어휘항목은 수치 리터럴, operator, 특수어를 포함한다.
- 프로그램은 문자보다는 어휘항목들로 구성된 문자열이라고 할 수 있다.
- [단언(assertion)](<https://en.wikipedia.org/wiki/Assertion_(software_development)>)
  - 문장 앞에 위치하면 프로그램의 그 지점에서 프로그램의 변수들에 대한 제약 사항이다.
  - 문장 뒤에 위치하면 그 문장이 실행된 후 해당 변수에 대한 새로운 제약 사항을 기술한다.
- 부프로그램(subprogram)은 전체 프로그램을 구성하는 조각이며, 함수 하나라고 생각할 수도 있을 것 같다.

<br />
<hr />

## 변수

- 변수는 name, address, value, type, lifetime, scope로 구성된다.

- #### **이름(name)**

  - 프로그램에서 어떤 개체를 식별하기 위해 사용되는 문자열이다.
  - 특수어(special word)는 수행될 행동들을 미리 정해 놓은 것이다.
    - 대부분의 언어에서 특수어는 예약어이다.
    - 어떤 언어에서 특수어는 단지 키워드이다.
    - 키워드(keyword)는 문맥에 따라 달라질 수 있다. _ex) javascript의 this_

- #### **주소(address)**

  - 그 변수와 연관된 기계 메모리 주소이다.
  - 두 개 이상의 변수 이름이 동일한 메모리 위치를 접근하는 데 사용되면, 그 변수들은 `별칭(alias)`이다.

- #### **타입(type)**

  - 그 변수가 저장할 수 있는 값들의 범위와 타입에 따른 연산들의 집합을 결정한다.

- #### **값(value)**

  - 그 변수에 연관된 추상적인 메모리 셀, 혹은 셀들의 내용이다.

- #### **바인딩(binding)**

  - 하나의 속성과 하나의 개체 간의 연관관게이다.
    - ex) 변수와 그 타입이나 값 사이, 연산과 기호 사이 등...
    - ex) `*` 기호는 보통 언어 설계 시간에 곱셈 연산에 바인딩된다.
    - ex) C의 `int` 데이터 타입은 언어 구현 시간에 가능한 값들의 범위에 바인딩된다.
  - `정적(static) 바인딩`: 실행 시간(runtime)이 시작되기 전에 일어나고, 프로그램 실행 전체에서 변하지 않는 상태로 남아있다.
    - 변수 이름과 타입이 동시에 바인딩된다.
  - `동적(dynamic) 바인딩`: 런타임 중에 일어나거나, 프로그램 실행 과정에서 변할 수 있다.

    - 변수 이름이 타입에 일시적으로 바인딩된다.
    - 동적 타입 바인딩을 사용하는 언어는 수치 데이터를 제네릭으로 작성한다.
    - 동적 타입 바인딩은 컴파일러 오류 탐지 능력이 떨어지므로 덜 신뢰적이다.

- #### **존속기간(lifetime)**

  - 변수가 특정 메모리 위치에 바인딩되어 있는 기간이다.
  - **정적**: 프로그램 실행이 시작되기 전에 메모리 셀에 바인딩되어, 종료될 때까지 동일한 메모리 셀에 바인딩되어 있다.
  - **스택-동적**: 선언문이 구현될 때 메모리에 바인딩되고, 타입은 정적으로 바인딩된다.
  - **힙-동적**: 실행 시간에 할당되고 회수되는 익명의 추상 메모리 셀에 바인딩되고, 포인터나 참조 변수로 참조한다.
  - **묵시적 힙-동적**: 값이 할당될 때마다 변수의 모든 속성이 힙 메모리에 바인딩된다.

- #### **영역(scope)**
  - 그 변수를 참조할 수 있는 문장들의 범위이다.
  - 변수가 프로그램 단위나 블록 내부에 정의되면 지역적(local)이다.
  - `정적 영역(static scope)`
    - 변수의 영역이 실행 전에 결정될 수 있다.
    - 많은 언어에서 새로운 정적 스코프를 실행 코드 중간에 정의할 수 있다.
      - 블록(block)으로 지정된 코드에 변수가 진입할 때 메모리에 할당, 빠져나올 때 회수된다.
      - 블록에 의해 생성된 영역은 subprogram(함수)에 의해 생성된 영역과 동일하게 취급된다.
      - javascript는 중첩된 함수에 대해 정적 스코프를 사용하지만, 블록 스코프는 그렇지 않다.
      - javascript에서 지역 변수는 함수의 어느 위치에서도 선언될 수 있지만, 변수의 영역은 항상 함수 전체이다.
        - **하지만 es6에서 블록-레벨 스코프인 let과 const가 나왔다!**
    - 전역 변수의 영역은 그 선언으로부터 프로그램 끝까지이다.
    - 참고로 javascript의 전역 변수는 동일한 이름을 갖는 지역 변수를 선언한 함수에서 그 전역 변수에 접근할 방법이 없다. (shadow variable)
    - 정적 영역을 사용할 때 소프트웨어는 계속 재구조화되어야 하므로, 변수와 함수에 대한 접근을 제어하기 위해 전역 변수 등을 많이 사용하게 된다.
  - `동적 영역(dynamic scope)`
    - 함수들이 배치된 관계가 아니라 호출 시퀀스에 기반하며, 실행 시간에 결정된다.
    ```javascript
    function big() {
      function sub1() {
        var x = 7;
      }
      function sub2() {
        var y = x;
        var z = 3;
      }
      var x = 3;
    }
    ```
    - 위의 sub2에서 참조되는 식별자 x의 의미는 동적이며, 컴파일 시간에 결정될 수 없다.
    - 어떠한 지역 선언에 대한 탐색이 실패하면, 그 함수의 부모에서 탐색되고, 이 과정을 반복한다. 이때 어떠한 부모에서도 발견되지 않으면 **실행-시간 오류**이다.
    - 동적 영역은 비지역 변수에 대한 참조를 정적으로 타입 검사할 수 없다.
    - 동적 영역은 참조의 의미를 결정하기 위한 함수 호출 시퀀스를 알아야 하므로 프로프램 판독이 힘들어진다.
- _(참고)_ **이름 상수(named constant)는 단지 한 번만 컴파일 시간에 값에 바인딩된느 변수이다.**
- _(참고)_ **초기화(initialization)는 변수가 메모리에 바인딩되는 시점에 값에 대한 변수의 바인딩이다.**l

(...ing)
