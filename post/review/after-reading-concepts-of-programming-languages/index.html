<!DOCTYPE html>
<html lang="kr-ko">
    <head>
        <meta name="description" content="프로그래밍 언어론을 읽고 내맘대로 정리해보았다." />

<meta name="og:type" content="website" />
<meta property="og:title" content="After reading &lt;concepts of programming languages&gt;" />
<meta property="og:site_name" content="After reading &lt;concepts of programming languages&gt;" />
<meta property="og:description" content="프로그래밍 언어론을 읽고 내맘대로 정리해보았다." />
<meta property="og:url" content="https://wacilpong.github.io/blog/post/review/after-reading-concepts-of-programming-languages/" />

<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="After reading &lt;concepts of programming languages&gt;" />
<meta name="twitter:description" content="프로그래밍 언어론을 읽고 내맘대로 정리해보았다." />

<meta property="og:image" content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512" />
<meta
  property="twitter:image:src"
  content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512"
/>


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-171393148-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());

  gtag("config", "UA-171393148-1");
</script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>After reading &lt;concepts of programming languages&gt;</title>
        
            <link rel="icon" href="https://wacilpong.github.io/blog/favicon.ico">
        
        <style>

    html body {
        font-family: 'Raleway', sans-serif;
        background-color: white;
    }

    :root {
        --accent: #469160;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://wacilpong.github.io/blog/css/main.css">


 <link rel="stylesheet" href="https://wacilpong.github.io/blog/css/custom.css"> 


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.73.0" />
        

        

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">After reading &lt;concepts of programming languages&gt;</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/blog/">Home</a></li>
                            
                                <li><a href="/blog/tags/">Category</a></li>
                            
                                <li><a href="/blog/post/">Posts</a></li>
                            
                                <li><a href="/blog/project/">Projects</a></li>
                            
                                <li><a href="/blog/learned/">What I Learned</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wacilpong/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/areum-han-a10645118/"><i class="fa fa-linkedin"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2>After reading &lt;concepts of programming languages&gt;</h2>
        <h5>2020-06-28</h5>
        
<a href="https://wacilpong.github.io/blog/tags/review"><kbd class="item-tag">review</kbd></a>

<a href="https://wacilpong.github.io/blog/tags/computer-science"><kbd class="item-tag">computer-science</kbd></a>


    </div>

    <div align="start" class="content"><p>by Robert W. Sebesta</p>
<p>프로그래밍 언어론을 읽고 내맘대로 정리해보았다.</p>
<p><br /></p>
<p><strong>[기본적인 사항]</strong></p>
<ul>
<li>프로그래밍 언어의 어휘항목은 수치 리터럴, operator, 특수어를 포함한다.</li>
<li>프로그램은 문자보다는 어휘항목들로 구성된 문자열이라고 할 수 있다.</li>
<li><a href="https://en.wikipedia.org/wiki/Assertion_(software_development)">단언(assertion)</a>
<ul>
<li>문장 앞에 위치하면 프로그램의 그 지점에서 프로그램의 변수들에 대한 제약 사항이다.</li>
<li>문장 뒤에 위치하면 그 문장이 실행된 후 해당 변수에 대한 새로운 제약 사항을 기술한다.</li>
</ul>
</li>
<li>부프로그램(subprogram)은 전체 프로그램을 구성하는 조각이며, 함수 하나라고 생각할 수도 있을 것 같다.</li>
<li>컴퓨터 과학에서 <strong>스칼라(scalar)</strong> 라고 지칭할 때는, 배열이든 문자열이든 상관없이 &lsquo;그것&rsquo;들 중의 하나를 의미한다.</li>
<li>프로그래밍 언어는 다음 세 가지 방법으로 구현(implementation)될 수 있다.
<ul>
<li>
<h4 id="1-compiler-implementation"><strong>(1) Compiler implementation</strong></h4>
<ul>
<li>컴퓨터에서 직접 실행될 수 있는 기계어로 번역될 수 있다.</li>
<li>컴파일러가 번역하는 언어는 원시언어(source language)이다.</li>
<li>컴파일 단계는 대체로 아래 순서를 거친다.
<ul>
<li><code>원시 프로그램 -&gt; 어휘 분석기 -&gt; 구문 분석기 -&gt; 중간 코드 생성기 -&gt; 코드 생성기</code></li>
<li>컴파일러에서는 주석을 사용하지 않으므로, 어휘 분석기는 원시 프로그램에 포함된 주석을 무시한다.</li>
<li>구문 분석기는 어휘들을 가져와 구문 구조를 표현한 <strong>파스 트리</strong>를 생성한다.</li>
<li>중간 코드 생성기는 원시 프로그램과 컴파일러의 최종 출력인 기계어 프로그램 간의 중간 수준에 위치한다.</li>
<li>코드 생성기는 프로그램의 최적화된 중간 코드 버전을 동등한 기계어 프로그램으로 변환한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="2-pure-interpretation"><strong>(2) Pure interpretation</strong></h4>
<ul>
<li>프로그램은 어떠한 번역 과정 없이 인터프리터에 의해 해석된다.</li>
<li>원시 수준의 디버깅 연산을 쉽게 구현할 수 있다.</li>
<li>그러나 고급 언어 문장을 해석(decode)해야 하므로, 컴파일된 시스템보다 10배 ~ 100배 실행 시간이 느리다.</li>
<li>문장이 몇 번 실행되는지 상관없이, 그 문장은 매번 해석되어야 한다.</li>
</ul>
</li>
<li>
<h4 id="3-hybrid-implementation-system"><strong>(3) Hybrid implementation system</strong></h4>
<ul>
<li>고급 언어 프로그램을 용이한 해석이 가능하도록 설계된 중간 언어로 번역한다.</li>
<li>따라서 원시 언어 문장을 한 번만 해석(decode)되므로 순수 해석보다 빠르다.</li>
<li><code>Perl</code> 프로그램은 해석 전에 오류를 탐지하고 부분적으로 컴파일된다.</li>
<li>JIT(Just In Time) 방식은 프로그램을 중간 언어로 번역하고, 실행 중에 중간 언어 메소드가 호출되면 그 메소드를 기게 코드로 번역한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="변수">변수</h2>
<ul>
<li>
<p>변수는 아래의 요소들로 구성된다.</p>
</li>
<li>
<h4 id="이름name"><strong>이름(name)</strong></h4>
<ul>
<li>프로그램에서 어떤 개체를 식별하기 위해 사용되는 문자열이다.</li>
<li>특수어(special word)는 수행될 행동들을 미리 정해 놓은 것이다.
<ul>
<li>대부분의 언어에서 특수어는 예약어이다.</li>
<li>어떤 언어에서 특수어는 단지 키워드이다.</li>
<li>키워드(keyword)는 문맥에 따라 달라질 수 있다. <em>ex) javascript의 this</em></li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="주소address"><strong>주소(address)</strong></h4>
<ul>
<li>그 변수와 연관된 기계 메모리 주소이다.</li>
<li>두 개 이상의 변수 이름이 동일한 메모리 위치를 접근하는 데 사용되면, 그 변수들은 <code>별칭(alias)</code>이다.</li>
</ul>
</li>
<li>
<h4 id="타입type"><strong>타입(type)</strong></h4>
<ul>
<li>그 변수가 저장할 수 있는 값들의 범위와 타입에 따른 연산들의 집합을 결정한다.</li>
</ul>
</li>
<li>
<h4 id="값value"><strong>값(value)</strong></h4>
<ul>
<li>그 변수에 연관된 추상적인 메모리 셀, 혹은 셀들의 내용이다.</li>
</ul>
</li>
<li>
<h4 id="바인딩binding"><strong>바인딩(binding)</strong></h4>
<ul>
<li>하나의 속성과 하나의 개체 간의 연관관게이다.
<ul>
<li>ex) 변수와 그 타입이나 값 사이, 연산과 기호 사이 등&hellip;</li>
<li>ex) <code>*</code> 기호는 보통 언어 설계 시간에 곱셈 연산에 바인딩된다.</li>
<li>ex) C의 <code>int</code> 데이터 타입은 언어 구현 시간에 가능한 값들의 범위에 바인딩된다.</li>
</ul>
</li>
<li><code>정적(static) 바인딩</code>: 실행 시간(runtime)이 시작되기 전에 일어나고, 프로그램 실행 전체에서 변하지 않는 상태로 남아있다.
<ul>
<li>변수 이름과 타입이 동시에 바인딩된다.</li>
</ul>
</li>
<li><code>동적(dynamic) 바인딩</code>: 런타임 중에 일어나거나, 프로그램 실행 과정에서 변할 수 있다.
<ul>
<li>변수 이름이 타입에 일시적으로 바인딩된다.</li>
<li>동적 타입 바인딩을 사용하는 언어는 수치 데이터를 제네릭으로 작성한다.</li>
<li>동적 타입 바인딩은 컴파일러 오류 탐지 능력이 떨어지므로 덜 신뢰적이다.</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="존속기간lifetime"><strong>존속기간(lifetime)</strong></h4>
<ul>
<li>
<p>변수가 특정 메모리 위치에 바인딩되어 있는 기간이다.</p>
</li>
<li>
<dl>
<dt><strong>정적</strong></dt>
<dd>프로그램 실행이 시작되기 전에 메모리 셀에 바인딩되어, 종료될 때까지 동일한 메모리 셀에 바인딩된다.</dd>
</dl>
</li>
<li>
<dl>
<dt><strong>스택-동적</strong></dt>
<dd>선언문이 구현될 때 메모리에 바인딩되고, 타입은 정적으로 바인딩된다.<br />
<em>ex) javascript의 함수 내부에 선언된 지역변수</em> -&gt; 따라서 재귀 호출이 가능해진다.</dd>
</dl>
</li>
<li>
<dl>
<dt><strong>힙-동적</strong></dt>
<dd>실행 시간에 할당되고 회수되는 익명의 추상 메모리 셀에 바인딩되고, 포인터나 참조 변수로 참조한다.</dd>
</dl>
</li>
<li>
<dl>
<dt><strong>묵시적 힙-동적</strong></dt>
<dd>값이 할당될 때마다 변수의 모든 속성이 힙 메모리에 바인딩된다.</dd>
</dl>
</li>
</ul>
</li>
<li>
<h4 id="영역scope"><strong>영역(scope)</strong></h4>
<ul>
<li>그 변수를 참조할 수 있는 문장들의 범위이다.</li>
<li>변수가 프로그램 단위나 블록 내부에 정의되면 지역적(local)이다.</li>
<li><code>정적 영역(static scope)</code>
<ul>
<li>변수의 영역이 실행 전에 결정될 수 있다.</li>
<li>많은 언어에서 새로운 정적 스코프를 실행 코드 중간에 정의할 수 있다.
<ul>
<li>블록(block)으로 지정된 코드에 변수가 진입할 때 메모리에 할당, 빠져나올 때 회수된다.</li>
<li>블록에 의해 생성된 영역은 subprogram(함수)에 의해 생성된 영역과 동일하게 취급된다.</li>
<li>javascript는 중첩된 함수에 대해 정적 스코프를 사용하지만, 블록 스코프는 그렇지 않다.</li>
<li>javascript에서 지역 변수는 함수의 어느 위치에서도 선언될 수 있지만, 변수의 영역은 항상 함수 전체이다.
<ul>
<li><strong>하지만 es6에서 블록-레벨 스코프인 let과 const가 나왔다!</strong></li>
</ul>
</li>
</ul>
</li>
<li>전역 변수의 영역은 그 선언으로부터 프로그램 끝까지이다.</li>
<li>참고로 javascript의 전역 변수는 동일한 이름을 갖는 지역 변수를 선언한 함수에서 그 전역 변수에 접근할 방법이 없다. (shadow variable)</li>
<li>정적 영역을 사용할 때 소프트웨어는 계속 재구조화되어야 하므로, 변수와 함수에 대한 접근을 제어하기 위해 전역 변수 등을 많이 사용하게 된다.</li>
</ul>
</li>
<li><code>동적 영역(dynamic scope)</code><br />
함수들이 배치된 관계가 아니라 호출 시퀀스에 기반하며, 실행 시간에 결정된다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">big</span>() {
  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sub1</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">7</span>;
  }
  <span style="color:#66d9ef">function</span> <span style="color:#a6e22e">sub2</span>() {
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">y</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">x</span>;
    <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">z</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
  }
  <span style="color:#66d9ef">var</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">3</span>;
}
</code></pre></div><ul>
<li>위의 sub2에서 참조되는 식별자 x의 의미는 동적이며, 컴파일 시간에 결정될 수 없다.</li>
<li>어떠한 지역 선언에 대한 탐색이 실패하면, 그 함수의 부모에서 탐색되고, 이 과정을 반복한다. 이때 어떠한 부모에서도 발견되지 않으면 <strong>실행-시간 오류</strong>이다.</li>
<li>동적 영역은 비지역 변수에 대한 참조를 정적으로 타입 검사할 수 없다.</li>
<li>동적 영역은 참조의 의미를 결정하기 위한 함수 호출 시퀀스를 알아야 하므로 프로프램 판독이 힘들어진다.</li>
</ul>
</li>
</ul>
</li>
<li>
<p><em>(참고)</em> <strong>이름 상수(named constant)는 단지 한 번만 컴파일 시간에 값에 바인딩되는 변수이다.</strong></p>
</li>
<li>
<p><em>(참고)</em> <strong>초기화(initialization)는 변수가 메모리에 바인딩되는 시점에 값에 대한 변수의 바인딩이다.</strong></p>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="데이터-타입">데이터 타입</h2>
<ul>
<li>
<p>데이터 값들의 모임과 그 값들에 대해 미리 정의된 연산들을 의미한다.</p>
</li>
<li>
<p>타입 시스템은 오류 탐지, 모듈 간 인터페이스 보장(cross-module), 문서화(documentation)로써 중요하다.</p>
</li>
<li>
<p>식별자를 변수로 생각할 수 있으나, 어떤 언어에서는 데이터 타입을 갖지 않으므로 변수 속성 중 하나이다.</p>
</li>
<li>
<p>Numeric, Boolean, String, Enum, Array, Tuple, List, Union, Pointer, Reference</p>
</li>
<li>
<h4 id="문자-스트링-타입character-string-type"><strong>문자 스트링 타입(Character string type)</strong></h4>
<ul>
<li>값이 일련의 문자들로 구성된다.</li>
<li>부분 스트링 참조는 주어진 문자열에서 부분 문자열에 대한 참조이며, 배열에서 논의될 때는 slice이다.</li>
<li>Perl, Javascript, Ruby, PHP는 패턴 매칭 연산자를 포함한다. 패턴 매칭 식은 수학적 정규식에 기초하고 있어서 정규식(regular expression)이라고 부른다.</li>
<li><code>정적 길이 스트링(static length string)</code>
<ul>
<li>스트링이 생성될 때 설정된다.</li>
<li><em>ex) Python이나 Java의 String</em></li>
</ul>
</li>
<li><code>제한된 동적 길이 스트링(limited dynamic length string)</code>
<ul>
<li>0부터 최대 길이까지의 임의의 문자들을 저장한다.</li>
</ul>
</li>
<li><code>동적 길이 스트링(dynamic length string)</code>
<ul>
<li>최대 길이의 제한이 없는 가변 길이를 갖는다.</li>
<li>유연하지만, 동적인 메모리 할당과 회수로 복잡한 기억공간 관리가 필요한데, 3가지 방법이 있다.
<ul>
<li>연결 리스트에 저장 -&gt; 링크에 대한 여분의 메모리가 필요하며, 스트링 연산이 복잡하다.</li>
<li>스트링을 힙에 할당된 개개의 문자들을 가리키는 포인터들의 배열로 저장 -&gt; 연결 리스트보다는 스트링 연산이 빠르다.</li>
<li>스트링 전체를 인접한 메모리 셀들에 저장 -&gt; 스트링이 늘어날 수록, 메모리 영역을 찾고 이전 셀을 회수하는 관리가 필요하다.</li>
</ul>
</li>
<li><em>ex) Javascript, Peral, C++의 String</em></li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="열거-타입enumeration-type"><strong>열거 타입(Enumeration type)</strong></h4>
<ul>
<li>이름이 있는 상수들이 열거되어, 열거 상수(enumeration constants)들을 정의하고 그룹핑하는 타입이다.</li>
<li>값을 할당하지 않아도 전형적으로 정수 값이 묵시적으로 할당된다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Hello</span> {
  <span style="color:#a6e22e">First</span>, <span style="color:#75715e">// 0
</span><span style="color:#75715e"></span>  <span style="color:#a6e22e">Second</span>, <span style="color:#75715e">// 1
</span><span style="color:#75715e"></span>}
</code></pre></div></li>
</ul>
</li>
<li>
<h4 id="배열-타입array"><strong>배열 타입(Array)</strong></h4>
<ul>
<li>동질적인 데이터 원소의 집합이며 C, C++, Java에서 배열의 모든 원소는 동일한 타입이어야 한다.</li>
<li>Javascript, Python, Ruby에서는 변수가 객체나 데이터 값에 대한 타입이 없는 참조이기 때문에, 배열의 원소들은 다른 타입들을 참조할 수 있다.</li>
<li>배열의 첨자(subscript)는 그 배열의 값을 가리키는 값이다. <em>ex) A[1]에서 1</em></li>
<li>Javascript 배열에서는 존재하지 않는 원소에 대해 참조하면 <strong>undefined</strong>를 반환한다.</li>
<li>배열의 슬라이드(slice)는 배열의 어떤 부분 구조이며, 주어진 첨자의 범위를 갖는 원소들로 구성된 배열을 반환한다.</li>
<li>배열 원소에 접근하는 코드는 컴파일에 생성되어야 하고, 런타임에 원소의 주소를 생성하도록 실행되어야 한다.</li>
<li><strong>연관 배열(associative array)</strong>
<ul>
<li>key-value 구조이다.</li>
<li>key를 통해 연관되는 값을 얻을 수 있는 자료구조이다.</li>
<li>Perl, Ruby 등에서 hash, Lua에서는 table타입이이 연관 배열이다.</li>
</ul>
</li>
<li><code>Union type vs Intersection type</code>
<ul>
<li>유니온 타입은 명시한 모든 타입들의 합집합이다.<br />
<em>ex) const test: A | B</em> -&gt; test는 A 또는 B타입</li>
<li>인터섹션 타입은 명시한 여러 타입을 하나의 단일 타입으로 결합한 일종의 교집합이다.<br />
<em>ex) const test: A &amp; B</em> -&gt; test는 A와 B타입 각각의 멤버를 1개 이상씩 가져야 한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="포인터-타입pointer"><strong>포인터 타입(Pointer)</strong></h4>
<ul>
<li>포인터는 동적으로 할당되는 힙 메모리의 한 위치를 접근하는 데 사용된다.</li>
<li>이미 회수된 힙-동적 변수의 주소를 가리키는 문제가 있다. (dangling pointer)
<ul>
<li>이때 힙-동적 변수를 garbage라고 부르며, 메모리 누수를 일으킨다.</li>
<li>이러한 문제로 최근의 언어들은 포인터를 참조 타입으로 대체해, 메모리 회수 문제를 최소화한다.</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="참조-타입reference-type"><strong>참조 타입(reference type)</strong></h4>
<ul>
<li>포인터는 메모리의 주소를 참조하지만, 참조 변수는 메모리의 객체나 값을 참조한다.</li>
<li>객체 지향 언어인 python, ruby, lua의 모든 변수는 참조 변수이다.</li>
<li>포인터와 참조 타입에서 쓰레기 회수
<ul>
<li>(1) 참조 계수기(reference counter)</li>
<li>(2) 표시-수집(mark-sweep)</li>
</ul>
</li>
</ul>
</li>
<li>
<p><em>(참고)</em> <strong>변수가 타입에 대한 바인딩이 정적이면 타입 검사도 항상 정적이며, 동적이면 런타임에서 타입 검사를 한다.</strong></p>
</li>
<li>
<p><em>(참고)</em> <strong>프로그래밍 언어는 타입 오류가 항상 탐지되면 강 타입 언어(strongly typed language)이다.</strong></p>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="식과-배정문expression-and-assignment-statement">식과 배정문(Expression and assignment statement)</h2>
<ul>
<li>식(expression)은 어떠한 단일 값으로 표현될 수 있는 코드이다.</li>
<li>문(statement)은 실행가능한 독립적인 코드 조각이다.
<ul>
<li>선택문(selection statement), 반복문(iterative statement)&hellip;</li>
<li>무조건 분기문(unconditional branch statement)은 실행 제어를 프로그램상에서 명시된 위치로 이동시킨다. 보통 루프 탈출로 사용하는데, 고급언어에서는 많이 사용하지 않는다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-batch" data-lang="batch">  :test
  <span style="color:#66d9ef">echo</span> <span style="color:#e6db74">&#34;hi&#34;</span>
  <span style="color:#66d9ef">goto</span> test
  ...
</code></pre></div></li>
</ul>
</li>
<li>많은 오류가 식 평가 과정에서 발생한다.
<ul>
<li>가장 공통된 오류는 연산의 결과가 저장되어야 하는 메모리 셀에 표현될 수 없을 때 발생한다.</li>
<li>ex) 그 결과가 너무 큰지 작은지에 따라 오버플로(overflow), 언더플로(underflow)이다.</li>
<li>소수점의 오버플로, 언더플로, 0에 의한 나누기는 런타임 오류이다.</li>
<li>런타임에서의 오류를 <strong>예외(exceptions)</strong> 라고도 부른다. <em>에러(error)와 다르다!</em></li>
</ul>
</li>
<li>할당문은 변수(상태)의 값을 변경하는 부수 효과(side effect)를 야기한다.
<ul>
<li><strong>함수에서의 사이드 이펙트는 함수가 자신의 매개변수들 중 하나 혹은 전역 변수를 변경할 때 발생한다.</strong></li>
<li>프로그램에서 동일한 값을 갖는 임의의 두 식이 프로그램 동작에 영향을 미치지 않으면서 임의의 위치에서 서로 다른 식으로 대체될 수 있다면, 그 프로그램은 referential transparet하다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">result1</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">fun</span>(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>) <span style="color:#f92672">/</span> (<span style="color:#a6e22e">fun</span>(<span style="color:#a6e22e">a</span>) <span style="color:#f92672">-</span> <span style="color:#a6e22e">c</span>);
<span style="color:#a6e22e">temp</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">fun</span>(<span style="color:#a6e22e">a</span>);
<span style="color:#a6e22e">result2</span> <span style="color:#f92672">=</span> (<span style="color:#a6e22e">temp</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">b</span>) <span style="color:#f92672">/</span> (<span style="color:#a6e22e">temp</span> <span style="color:#f92672">-</span> <span style="color:#a6e22e">c</span>);
</code></pre></div><p>위 코드에서 함수 fun이 사이드 이펙트가 없다면 result1과 result2는 동일해야 한다.</p>
</li>
</ul>
</li>
<li>타입 강제 변환은 컴파일러가 수행하는 묵시적 타입 변환(implicit type conversion)이다.
<ul>
<li>명시적인 타입 변환은 명시적 타입 변환(Explicit Type Conversion) 또는 캐스트(cast)이다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="부프로그램subprogram">부프로그램(Subprogram)</h2>
<ul>
<li>
<p><strong>overloaded subprogram은 동일한 참조 환경에서 다른 이름을 갖는다.</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span>: <span style="color:#66d9ef">number</span>);
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span>: <span style="color:#66d9ef">boolean</span>);
<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>(<span style="color:#a6e22e">a</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>;
}

<span style="color:#a6e22e">test</span>(<span style="color:#ae81ff">1</span>);
<span style="color:#a6e22e">test</span>(<span style="color:#66d9ef">true</span>);
<span style="color:#a6e22e">test</span>(<span style="color:#e6db74">&#34;1&#34;</span>); <span style="color:#75715e">// No overload matches this call
</span></code></pre></div></li>
<li>
<p><strong>generic subprogram은 호출할 때마다 다른 타입의 데이터에 게산을 수행한다.</strong></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>&lt;<span style="color:#f92672">T</span>&gt;(<span style="color:#a6e22e">a</span>: <span style="color:#66d9ef">T</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">a</span>;
}

<span style="color:#a6e22e">test</span>&lt;<span style="color:#f92672">number</span>&gt;(<span style="color:#ae81ff">1</span>);
<span style="color:#a6e22e">test</span>&lt;<span style="color:#f92672">boolean</span>&gt;(<span style="color:#ae81ff">1</span>); <span style="color:#75715e">// type error
</span></code></pre></div></li>
<li>
<p>부프로그램의 header는 헤더 다음에 오는 구문이 어떤 종류(특히 프로시저, 함수)인지 명시한다.</p>
</li>
<li>
<p>간접적으로 부프로그램을 호출하는 일반적인 에시는 <code>콜백(callback)</code>이다.</p>
</li>
<li>
<p>부프로그램의 형식 부분인 배치(layout)를 활성화 레코드(activation record)라고 하며, 정적 바인딩 된다.</p>
</li>
<li>
<p>일단 <strong>Javascript에서의 부프로그램은 함수라고 볼 수 있으므로, 함수라고 지칭하려고 한다.</strong></p>
</li>
<li>
<p>함수는 구조적으로 프로시저를 닮았지만 의미적으로는 수학 함수가 모델이다.</p>
</li>
<li>
<p>함수는 새로운 사용자 정의 연산자를 정의한다. 예를 들어, 어떤 언어에 지수 연산자가 없다면 이 연산을 할 수 있는 함수를 작성할 수 있다. 아래 result의 결과는 동일하다.</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-c++" data-lang="c++"><span style="color:#75715e">// c++
</span><span style="color:#75715e"></span><span style="color:#66d9ef">float</span> <span style="color:#a6e22e">power</span>(<span style="color:#66d9ef">float</span> base, <span style="color:#66d9ef">float</span> exp) {
  <span style="color:#66d9ef">float</span> result <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

  <span style="color:#66d9ef">while</span> (exp <span style="color:#f92672">!=</span> <span style="color:#ae81ff">0</span>) {
    result <span style="color:#f92672">*=</span> base;
    <span style="color:#f92672">--</span>exp;
  }

  <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0</span>;
}

result <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.4</span> <span style="color:#f92672">*</span> power(<span style="color:#ae81ff">10.0</span>, x)
result <span style="color:#f92672">=</span> <span style="color:#ae81ff">3.4</span> <span style="color:#f92672">*</span> <span style="color:#ae81ff">10.0</span> <span style="color:#f92672">**</span> x
</code></pre></div></li>
<li>
<h4 id="매개변수"><strong>매개변수</strong></h4>
<ul>
<li>매개변수로 전달된 데이터는 함수의 지역 변수로 접근된다.</li>
<li>접근하는 데이터가 비지역 변수라면 함수의 호출 사이에 그 비지역 변수에 새로운 값을 할당해야 한다.<br />
-&gt; side effect!</li>
<li>메소드는 비지역 참조와 매개변수를 통해 외부 데이터에 접근한다.<br />
-&gt; side effect!
<ul>
<li>메소드가 처리하는 데이터는 메소드가 호출된 객체이다.</li>
<li><em>ex) javascript의 객체 내부에 선언된 함수를 호출</em></li>
</ul>
</li>
<li>Haskell과 같은 순수 함수형 프로그래밍 언어는 변화할 수 있는 데이터를 갖지 않는다.
<ul>
<li>따라서 어떤 방법으로든 메모리를 변화시킬 수 없다.</li>
<li>단순히 계산을 하고 결과 값(또는 함수, 함수도 값이다)을 반환한다.</li>
</ul>
</li>
<li><code>parameter: 부프로그램 헤더에 명시된 매개변수</code></li>
<li><code>argument: 부프로그램을 호출할 때 그 파라미터에 바인딩되는 매개변수, 인수</code>
<ul>
<li>parameter는 디폴트 값을 갖는다.</li>
<li><em>ex) function test(a, b = 1)</em></li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="지역-참조-환경"><strong>지역 참조 환경</strong></h4>
<ul>
<li>지역 변수는 함수 내부에 정의되고, 스코프가 함수의 본문에 제한된다.</li>
<li>지역 변수가 스택-동적이면 함수가 실행될 때 메모리에 바인딩되고 끝날 때 해제된다.
<ul>
<li>재귀 함수의 지역 변수는 스택-동적이어야만 한다.</li>
<li>스택-동적 지역 변수에 대한 접근은 간접 주소 방식이다.</li>
<li>지역 변수가 스택의 어디에 위치할지 런타임에서만 결정할 수 있기 때문이다.</li>
<li>대부분의 현대 언어에서 함수의 지역 변수는 디폴트로 스택-동적이다.</li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="함수"><strong>함수</strong></h4>
<ul>
<li>
<p>대부분의 언어에서 함수는 값을 전달하거나 참조 전달되는 매개변수를 갖는다.<br />
-&gt; side effect, alias 발생</p>
</li>
<li>
<p>특정 언어에서 부프로그램은 일급 객체이다.</p>
<ul>
<li>매개변수로 전달될 수 있고, 함수로부터 반환될 수 있고, 변수에 배정될 수 있다.</li>
<li><em>ex) javascript의 function</em></li>
</ul>
</li>
<li>
<p><strong>클로저(closure)는 중첩된 부프로그램의 참조 환경이다.</strong></p>
<ul>
<li>부프로그램이 프로그램의 임의의 위치에서 호출되는 것을 허용한다.</li>
<li>따라서 이때 변수의 존속기간은 정의된 함수가 아니라 전체 프로그램의 활성화 기간이다.</li>
<li>거의 모든 함수형 프로그래밍 언어는 클로저를 지원한다.</li>
<li>이 언어들은 <strong>정적 스코프이며, 중첩 함수를 허용하고, 함수가 매개변수로 전달될 수 있다.</strong></li>
<li>아래 예시에서 makeAdder가 호출될 때 생성되는 x의 존속기간은 프로그램 존속기간이 된다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">function</span> <span style="color:#a6e22e">makeAdder</span>(<span style="color:#a6e22e">x</span>) {
  <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">function</span> (<span style="color:#a6e22e">y</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#a6e22e">x</span> <span style="color:#f92672">+</span> <span style="color:#a6e22e">y</span>;
  };
}

<span style="color:#66d9ef">var</span> <span style="color:#a6e22e">add10</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">makeAdder</span>(<span style="color:#ae81ff">10</span>);

document.<span style="color:#a6e22e">write</span>(<span style="color:#a6e22e">add10</span>(<span style="color:#ae81ff">20</span>));
</code></pre></div></li>
</ul>
</li>
</ul>
</li>
<li>
<h4 id="코루틴"><strong>코루틴</strong></h4>
<ul>
<li>코루틴은 특별한 종류의 부프로그램이다.</li>
<li>코루틴의 시작은 호출(call)이라기보다는 리쥼(resume)이라고 불린다.</li>
<li>부프로그램의 특징처럼, 코루틴도 주어진 시점에서는 하나의 코루틴만 실제로 실행된다.
<ul>
<li>모든 코루틴이 구성되었을 때 마스터 프로그램은 하나를 리쥼한다.</li>
<li>나머지 코루틴들은 작업이 끝날 때까지 어떠한 순서로 서로서로 리쥼한다.</li>
<li>코루틴 실행이 코드 끝부분에 도착하면 제어는 이 코루틴을 생성한 마스터로 전달되어 끝난다.</li>
<li>따라서 코루틴은 병렬로 실행하는 것처럼 보인다.</li>
</ul>
</li>
<li><em>ex) javascript의 generator와 async/await</em></li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="동시성concurrency">동시성(Concurrency)</h2>
<ul>
<li>소프트웨어에서 동시성은 다음의 4가지 수준에서 발생한다.
<ul>
<li>명령어, 문장, 단위, 프로그램</li>
<li><strong>프로그래밍 언어에서는 단위(함수) 수준과 문장 수준에서 논의된다.</strong></li>
<li>ex) 웹 브라우저는 동시에 많은 함수를 실행해야 한다.</li>
<li>종류
<ul>
<li><code>물리적 동시성</code>: 동일한 프로그램으로부터 여러 프로그램 단위를 동시에 실행</li>
<li><code>논리적 동시성</code>: 실제로는 단일 프로세서로 프로그램을 실행하나, 다수의 프로세서가 있다고 가정해 동시에 실행
<ul>
<li>단일 프로세서에서 인터리브(interleave) 방식을 통한다.</li>
<li>이는 데이터가 인접하지 않게 배열하는 방식이다.</li>
<li>ex) Python, Ruby 같은 인터프리팅 언어는 논리적 동시성 뿐, 컴퓨터가 다중 프로세서이더라도 1개를 초과해 실행될 수 없다.</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>제어의 스레드(thread of control)</strong>
<ul>
<li>프로그램이 실행되면서 도달된 지점들의 순서 열이다.</li>
</ul>
</li>
<li><strong>태스크(task)</strong>
<ul>
<li>동일한 프로그램 딘위들과 함께 동시 실행 상태에 있을 수 있는 단위이다.</li>
<li>태스크는 때때로 프로세스(process)라고 부른다.</li>
<li>Java, C# 등의 언어에서 어떤 메서드는 태스크로 동작하고, 이는 스레드 객체에서 실행된다.</li>
<li>태스크의 상태는 다음과 같다.
<ul>
<li><strong>신규(new)</strong></li>
<li><strong>준비(ready)</strong>: 여기서 실행상태로 바꾸기 위해 dispatch가 일어난다.</li>
<li><strong>실행(running)</strong></li>
<li><strong>종료(terminated)</strong></li>
<li><strong>봉쇄(block)</strong></li>
</ul>
</li>
<li>2개 이상의 태스크가 공용 자원을 위해 경쟁하는 문제(race condition)가 발생할 수 있다.</li>
<li><code>교착 상태(deadlock)</code>는 태스크 A는 X, B는 Y를 소유하고 있을 때 서로의 자원을 요청하는 상황이다.</li>
<li>이러한 상황들을 해결하기 위해 세마포어, 모니터, 메시지 전달과 같은 방법이 있다.</li>
</ul>
</li>
<li>
<h4 id="세마포어">세마포어</h4>
<ul>
<li>보호(guard)는 보호된 코드가 특정 조건에서만 실행되는 것을 허용하는 장치이다.</li>
<li>세마포어는 이러한 보호의 구현이다.</li>
<li><em>ex) javascript 어떤 프로미스를 동시에 1개만 실행할 때</em>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">let</span> <span style="color:#a6e22e">count</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">withSemaphore</span>() {
  <span style="color:#66d9ef">if</span> (<span style="color:#a6e22e">count</span> <span style="color:#f92672">&lt;=</span> <span style="color:#ae81ff">0</span>) <span style="color:#66d9ef">return</span>;

  <span style="color:#a6e22e">test</span>();
}

<span style="color:#66d9ef">function</span> <span style="color:#a6e22e">test</span>() {
  <span style="color:#a6e22e">count</span> <span style="color:#f92672">-=</span> <span style="color:#ae81ff">1</span>;
  <span style="color:#a6e22e">somePromise</span>().<span style="color:#66d9ef">finally</span>(() =&gt; (<span style="color:#a6e22e">count</span> <span style="color:#f92672">+=</span> <span style="color:#ae81ff">1</span>));
}
</code></pre></div></li>
</ul>
</li>
<li>
<h4 id="모니터">모니터</h4>
<ul>
<li>공유 데이터 구조를 추상 데이터 타입으로 만들어 은폐한다.</li>
<li>이를 통해 동기화에 대한 책임을 런타임으로 이전한다.</li>
<li>공유 데이터가 클라이언트 단위가 아니라 모니터 내에(버퍼에) 상주해야 한다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="예외-처리와-이벤트-처리">예외 처리와 이벤트 처리</h2>
<ul>
<li>하드웨어로는 탐지할 수 없지만, 컴파일러가 생성한 코드 기반으로 탐지하는 오류들이 있다.</li>
<li>배열의 첨자 범위 오류는 프로그램 실행에서 가끔 나중에 인식되는 치명적인 오류이기도 하다.</li>
<li><strong>예외(exception)</strong>
<ul>
<li>하드웨어나 소프트웨어로 탐지될 수 있다.</li>
<li>특별한 조치가 필요하거나 필요하지 않을 수 있는 독특한 이벤트이다.</li>
<li>언어가 예외 처리 기능이 있으면, 예외를 전파할 수 있어 재사용할 수 있다.
<ul>
<li><em>ex) api호출 시 에러가 발생하면 throw하는 핸들러</em></li>
</ul>
</li>
<li>미리 정의된 예외는 묵시적이지만, 사용자-정의 예외는 사용자 코드에 의해 명시적으로 발생한다.</li>
<li><strong>독특하지만 오류가 아닌 이벤트에 관련된 상황에서는 실행의 연속이 가장 좋은 선택이다.</strong>
<ul>
<li>딱히 프로그램에 문제를 일으키지는 않으므로.</li>
<li>이러한 설계를 <strong>실행 재개(resumption)</strong> 라고 한다.</li>
<li><em>ex) javascript Promise.reject()</em></li>
</ul>
</li>
<li><strong>실행이 어떻게 종료되었든 무조건 완료하는 것이 필요할 수도 있다.</strong>
<ul>
<li><em>ex) javascript Promise.finally()</em></li>
<li><em>ex) javascript try catch finally</em></li>
</ul>
</li>
</ul>
</li>
<li><strong>이벤트(event)</strong>
<ul>
<li>그래픽 버튼의 마우스 클릭처럼 무언가 특별한 것이 발생했다는 동작</li>
<li>엄격하게 말하면, 이벤트는 사용자 작용에 대한 반응으로 묵시적으로 생성되는 객체</li>
<li>이벤트 핸들러는 프로그램이 사용자 동작에 응답하도록 한다.
<ul>
<li>최근 웹은 <strong>event-drievven 형태의 렌더링</strong> 방식으로, <code>addEventListener()</code> 메서드를 이용한다.</li>
<li>이를 통해 이벤트 emitter로 수많은 객체를 정의하고, 이 객체들이 여러 Event Type을 정의한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="추상-데이터-타입과-캡슐화-구조">추상 데이터 타입과 캡슐화 구조</h2>
<ul>
<li><strong>추상 데이터 타입</strong>
<ul>
<li>한 개의 특별한 데이터 타입의 데이터 표현과 그 타입의 연산을 제공하는 부프로그램만을 포함하는 클로저</li>
<li>객체의 데이터 멤버는 클라이언트로부터 은폐되어야 한다.</li>
<li>그러나 멤버로 접근하는 경우가 많아, 일반적으로 접근자 메서드인 <code>getter, setter</code>를 사용한다.</li>
<li>고려해야할 4가지 연산이 있다.
<ul>
<li><code>iterator</code></li>
<li><code>accessor</code>: 직접 접근이 금지된 데이터에 대한 접근 제공</li>
<li><code>constructo</code>: 새롭게 생성된 객체의 일부분을 초기화하는 데 사용</li>
<li><code>destructor</code>: 사용된 힙 기억 공간(heap storage)을 다시 회수하는 데 사용</li>
</ul>
</li>
<li>C++에서의 클래스는 타입이며, 정적, 스택-동적, 힙-동적일 수 있다.
<ul>
<li>스택-동적 클래스 인스턴스의 존속기간은 그 선언의 영역 끝에 도달할 때 끝난다.</li>
<li>힙-동적 클래스는 new 연산자로 생성되고 delete 연산자로 소멸된다.</li>
</ul>
</li>
<li>Java에서 모든 객체들은 힙에서 할당되고 참조 변수를 통해 접근된다.</li>
<li>Ruby에서 인스턴스 변수의 이름은 <strong>@(at sign)</strong> 으로 시작하는 특수한 구문이다.
<ul>
<li>생성자는 <strong>initialize</strong> 라는 명칭이며, 클래스당 하나만 존재한다.</li>
<li>메서드 접근 제어는 동적이어서, 런타임에서 비로소 탐지할 수 있다.</li>
</ul>
</li>
</ul>
</li>
<li><strong>캡슐화 구조</strong>
<ul>
<li>규모가 큰 프로그램은 재컴파일 비용이 중요해진다.</li>
<li>따라서 논리적으로 관련된 코드와 데이터 집합으로 조직화하여 각 집합을 재컴파일하지 않게 해야 한다.</li>
<li>이때 각 집합이 바로 캡슐화인 것이다.</li>
<li>캡슐화는 종종 라이브러리에 사용하고, 캡슐화가 쓰여진 프로그램 외의 다른 프로그램에서도 재사용된다.</li>
<li><em>ex) Java의 package, Ruby의 module</em></li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="객체-지향-프로그래밍">객체 지향 프로그래밍</h2>
<ul>
<li>객체 지향 언어는 추상 데이터 타입, 상속, 메서드에 대한 메서드 호출의 동적 바인딩을 지원해야 한다.</li>
<li><strong>상속</strong>
<ul>
<li>객체 지향 언어에서 추상 데이터 타입은 일반적으로 class라고 불린다.</li>
<li>클래스의 객체에 연산을 정의하는 부프로그램은 method라고 불린다.</li>
<li>어떠한 클래스에서 분화된 서브클래스는 상속받은 메서드의 동작을 조작할 수 있다.</li>
<li><code>오버라이딩</code>의 목적은 부모 클래스에 있는 연산과 유사하지만 서브클래스 객체에 적합한 연산을 하기 위함이다.</li>
</ul>
</li>
<li><strong>동적 바인딩</strong>
<ul>
<li>메시지를 메서드 정의에 동적 바인딩해서 메서드 호출에 대한 다형성을 제공해야 한다.</li>
<li>아래 상황과 같을 때 draw 메서드가 다형 참조를 통해 호출된다면, 런타임에서 어느 메서드인지를 결정해야 한다.</li>
<li>이것이 동적 바인딩이며 객체 지향 프로그래밍에서 반드시 설계되어야 하는 것이다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-ts" data-lang="ts"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">A</span> {
  <span style="color:#a6e22e">draw() {</span>...}
}
    
<span style="color:#66d9ef">public</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">B</span> <span style="color:#66d9ef">extends</span> <span style="color:#a6e22e">A</span> {
  <span style="color:#a6e22e">draw() {</span>...}
}
</code></pre></div></li>
</ul>
</li>
<li>다중상속의 사용은 복잡한 프로그램 구조가 되기 쉽다.</li>
<li>Java는 단일 상속만 지원하나, 인터페이스를 제공하여 다중 상속을 간접적으로 할 수 있다.</li>
<li>Ruby에서 모든 변수는 다형이고 메서드에 대한 메서드 호출의 모든 바인딩이 동적이다.</li>
</ul>
<p><br /></p>
<hr />
<h2 id="함수형-프로그래밍">함수형 프로그래밍</h2>
<ul>
<li>수학 함수에 기초하여 비명령형 스타일이 설계 기준이다.</li>
<li>명령형으로 작성된 프로그램의 기본 특성 중 하나는 런타임에서 변하는 상태를 갖는다는 것이다.</li>
<li>그 변하는 상태가 바로 <strong>변수</strong>로 표현된다.</li>
<li><strong>하지만 함수형 언어는 변수나 상태를 갖지 않는다.</strong></li>
<li>수학에서의 함수는 정의역을 치역으로 mapping한 것이다.</li>
<li>Alonzo Church가 고안한 람다 기호는 무기명 함수를 정의하는 방법이다.</li>
<li><code>람다 표현식 (lambda expression)</code>: 매개변수와 함수와의 사상(mapping)이다.</li>
<li>ex) <em>Haskell은 순수한 함수형 언어이다.</em>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">sub</span> <span style="color:#a6e22e">n</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">10</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">n</span> <span style="color:#f92672">&gt;</span> <span style="color:#ae81ff">100</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
  <span style="color:#f92672">|</span> <span style="color:#a6e22e">otherwise</span> <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
</code></pre></div></li>
<li>함수형에서 반복은 일반적인 순차와 반복보다는 재귀와 조건식으로 제어된다.
<ul>
<li>반복 구조는 변수로 제어되기 때문이다.</li>
<li>함수의 재귀 호출이 함수의 마지막 연산이라면 <code>꼬리 재귀(tail recursive)</code>라고 한다.</li>
<li>반복을 위해 재귀를 사용하는 많은 함수는 꼬리 재귀가 아니다.</li>
<li>아래 함수의 마지막 연산은 곱셈이므로 꼬리 재귀가 아니다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#75715e">// scheme
</span><span style="color:#75715e"></span>(<span style="color:#a6e22e">DEFINE</span> (<span style="color:#a6e22e">factorial</span> <span style="color:#a6e22e">n</span>)
  (<span style="color:#a6e22e">IF</span> (<span style="color:#f92672">&lt;=</span> <span style="color:#a6e22e">n</span> <span style="color:#ae81ff">1</span>)
    <span style="color:#ae81ff">1</span>
    (<span style="color:#f92672">*</span>  <span style="color:#a6e22e">n</span> (<span style="color:#a6e22e">factorial</span>  (<span style="color:#f92672">-</span><span style="color:#a6e22e">n</span> <span style="color:#ae81ff">1</span>)))
))
</code></pre></div></li>
</ul>
</li>
<li>프로그래밍 언어는 모든 실 매개변수가 완전히 평가되기를 요구한다면 strict하다고 한다.
<ul>
<li>함수의 값이 매개변수가 평가되는 순서에 종속하지 않음을 보증한다.</li>
<li>그렇지 않다면 nonstrict하며, 지연 평가를 할 수 있다.</li>
<li>지연 평가는 엄밀히 말하면 무한 데이터 구조를 정의하는 것을 허용한다.</li>
<li><code>지연 평가(lazy evaluation)</code>: 값이 필요할 때만 표현식이 평가된다.</li>
</ul>
</li>
<li>과거 명령형 언어의 가장 중요한 제한은 고차함수를 지원하지 않는 것이었다.</li>
<li>그러나 람다표현식과 같은 무기명 함수는 js, python, ruby, C#의 일부가 되었다.</li>
<li>최근에는 대부분의 함수형 언어를 위한 컴파일러가 있어서 명령형 언어와의 실행 속도 차이는 크지 않다.</li>
</ul>
<p><br /></p>
<hr />
<h2 id="논리형-프로그래밍">논리형 프로그래밍</h2>
<ul>
<li>논리형 프로그램은 절차적이기보다는 선언적이다.</li>
<li>선언적인 것은 결과를 도출하기 위한 절차가 아니라 원하는 결과의 명세가 서술된다는 것을 의미한다.</li>
<li>명령형과 함수형 언어는 기본적으로 절차적이다. 즉, 컴퓨터는 명령을 따르는 장치로만 취급된다.</li>
<li>논리형은 결과가 계산되는 방법을 정확히 서술하지 않고 결과의 형식을 기술한다.</li>
<li><code>명제(proposition)</code>: 참이거나 거짓인 논리적 문장
<ul>
<li>기본 명제는 복합 항으로 구성된다.</li>
<li>관계를 명명하는 함수 기호인 functor와 관계의 원소들을 나타내는 순서 리스트로 구성된다.</li>
</ul>
</li>
<li><code>functor</code>
<ul>
<li>같은 구조에서 새로운 결과를 도출하기 위해 순회되는 구조를 의미한다.</li>
<li>즉, 아래 예시에 선언된 Wrapper 클래스는 functor라고 할 수 있다.</li>
<li><em>ex) js Array, Class&hellip;</em>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Wrapper</span> {
  <span style="color:#a6e22e">constructor</span>(<span style="color:#a6e22e">v</span>) {
    <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">v</span>;
  }

  <span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">f</span>) {
    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Wrapper</span>(<span style="color:#a6e22e">f</span>(<span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">value</span>))
  }
}

<span style="color:#66d9ef">new</span> <span style="color:#a6e22e">Wrapper</span>(<span style="color:#ae81ff">39</span>).<span style="color:#a6e22e">map</span>(<span style="color:#a6e22e">addThree</span>);
</code></pre></div></li>
</ul>
</li>
<li>논리형 프로그래밍 언어 <code>Prolog</code>
<ul>
<li><strong>사실(fact)과 규칙(rules)들을 제공하여 데이터베이스를 만들고 질의를 던져서 프로그램을 수행한다.</strong></li>
<li>아래는 bob은 아버지라는 사실과, X가 아버지라면 X는 남자라는 규칙이다.</li>
<li>둘의 체이닝을 통해 X를 bob으로 치환하여 명제가 도출된다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-js" data-lang="js"><span style="color:#a6e22e">father</span>(<span style="color:#a6e22e">bob</span>)
<span style="color:#a6e22e">man</span>(<span style="color:#a6e22e">X</span>)  <span style="color:#f92672">:-</span>  <span style="color:#a6e22e">father</span>(<span style="color:#a6e22e">X</span>).
</code></pre></div></li>
</ul>
</li>
</ul>
</div>

    
    
    
        <h4 class="page-header">Related</h4>
         <div class="item">

    
    
    

    
    

    <h4><a href="/blog/post/review/after-reading-from-mathematics-to-generic-programming/">After reading &lt;from math to generic programming&gt;</a></h4>
    <h5>2021-03-31</h5>
    
<a href="https://wacilpong.github.io/blog/tags/review"><kbd class="item-tag">review</kbd></a>



</div>
  <div class="item">

    
    
    

    
    

    <h4><a href="/blog/post/review/good-bye-2020/">Good bye 2020</a></h4>
    <h5>2020-12-23</h5>
    
<a href="https://wacilpong.github.io/blog/tags/review"><kbd class="item-tag">review</kbd></a>



</div>
  <div class="item">

    
    
    

    
    

    <h4><a href="/blog/post/review/after-reading-code/">After reading &lt;code&gt;</a></h4>
    <h5>2020-11-18</h5>
    
<a href="https://wacilpong.github.io/blog/tags/review"><kbd class="item-tag">review</kbd></a>

<a href="https://wacilpong.github.io/blog/tags/computer-science"><kbd class="item-tag">computer-science</kbd></a>



</div>
 
    

    
    
        <h4 class="page-header">Comments</h4>
        <div id="disqus_thread"></div>
<script type="application/javascript">
    var disqus_config = function () {
    
    
    
    };
    (function() {
        if (["localhost", "127.0.0.1"].indexOf(window.location.hostname) != -1) {
            document.getElementById('disqus_thread').innerHTML = 'Disqus comments not available by default when the website is previewed locally.';
            return;
        }
        var d = document, s = d.createElement('script'); s.async = true;
        s.src = '//' + "roomy-han" + '.disqus.com/embed.js';
        s.setAttribute('data-timestamp', +new Date());
        (d.head || d.body).appendChild(s);
    })();
</script>
<noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
<a href="https://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>
    

</main>

        <footer>
            <p class="copyright text-muted">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>.</p>
        </footer>

        

        
    </body>

</html>

