<!DOCTYPE html>
<html lang="kr-ko">
    <head>
        <meta name="description" content="Smart Pointers" />

<meta name="og:type" content="website" />
<meta property="og:title" content="After reading Rust book chapter 15" />
<meta property="og:site_name" content="After reading Rust book chapter 15" />
<meta property="og:description" content="Smart Pointers" />
<meta property="og:url" content="https://wacilpong.github.io/blog/study/rust/rust-15/" />

<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="After reading Rust book chapter 15" />
<meta name="twitter:description" content="Smart Pointers" />

<meta property="og:image" content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512" />
<meta
  property="twitter:image:src"
  content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512"
/>


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-171393148-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());

  gtag("config", "UA-171393148-1");
</script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>After reading Rust book chapter 15</title>
        
            <link rel="icon" href="https://wacilpong.github.io/blog/favicon.ico">
        
        <style>

    html body {
        font-family: 'Raleway', sans-serif;
        background-color: white;
    }

    :root {
        --accent: #469160;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://wacilpong.github.io/blog/css/main.css">


 <link rel="stylesheet" href="https://wacilpong.github.io/blog/css/custom.css"> 


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.62.0" />
        

        

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">After reading Rust book chapter 15</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/blog/">Home</a></li>
                            
                                <li><a href="/blog/tags/">Category</a></li>
                            
                                <li><a href="/blog/post/">Posts</a></li>
                            
                                <li><a href="/blog/study/">Study</a></li>
                            
                                <li><a href="/blog/learned/">What I Learned</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wacilpong/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/areum-han-a10645118/"><i class="fa fa-linkedin"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2>After reading Rust book chapter 15</h2>
        <h5></h5>
        
<a href="https://wacilpong.github.io/blog/tags/rust"><kbd class="item-tag">rust</kbd></a>


    </div>

    <div align="start" class="content"><ul>
<li>포인터(pointer)는 메모리에 주소를 가지고 있는 변수를 일컫는 보편적인 개념이다.</li>
<li>러스트에서 가장 대중적인 포인터는 &amp;기호를 사용한 참조, 변수가 가리키는 값을 대여한다.</li>
<li>스마트 포인터(smart pointer)는 포인터처럼 동작할 뿐만 아니라 추가 메타데이터를 포함한다.
<ul>
<li><strong>러스트에서 참조는 데이터를 대여할 수만 있지만, 스마트 포인터는 가리키는 데이터를 소유할 수 있다.</strong></li>
<li>ex. <code>String</code>, <code>Vec&lt;T&gt;</code> -&gt; 두 타입은 메모리를 소유하며 데이터를 갱신할 수 있다.</li>
<li>스마트 포인터는 주로 구조체를 이용해 구현한다.</li>
<li><code>Deref</code>,<code>Drop</code> 트레이트를 구현해야 한다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="1-boxt-----">1. Box<T>를 이용한 힙 메모리의 데이터 참조</h2>
<ul>
<li>Box는 데이터를 힙 메모리에 저장하고, 데이터를 가리키는 포인터만 스택에 저장한다.</li>
<li>Box를 주로 사용하는 예시:
<ul>
<li>컴파일 타임에 크기를 알 수 없는 타입을 정확한 크기가 필요한 상황에 사용할 때</li>
<li>데이터 크기가 커서 데이터를 복제하지 않고 소유권만 이전하고 싶을 때</li>
<li>특정 타입이 아닌 특정 트레이트를 구현하는 타입의 값을 소유할 때</li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="1-1-----">1-1. 힙 메모리에 박스 데이터 저장하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Box::new(<span style="color:#ae81ff">5</span>);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;b = {}&#34;</span>, b);
}
</code></pre></div><ul>
<li>변수 b에는 힙 메모리에 할당된 5라는 값을 가리키는 Box를 대입한다.</li>
<li>소유된 값과 마찬가지로 b는 main 함수 끝에 도달해서 박스가 스코프를 벗어나면 메모리 해제된다.</li>
<li>즉, 스택에 저장된 박스와 힙에 저장된 박스가 가리키는 데이터의 메모리가 모두 해제된다.</li>
</ul>
<p><br /></p>
<h3 id="1-2----">1-2. 박스와 재귀 타입 활용하기</h3>
<ul>
<li>컴파일 타임에 크기를 알 수 없는 타입 중 하나는 재귀 타입(recursive type)이다.</li>
<li>재귀 타입이란 같은 타입의 다른 값을 자신의 일부에 포함하는 값이다.</li>
<li>값을 중첩하면 이론적으로는 무한할 수 있어서 러스트는 재귀 타입 값에 필요한 공간을 판단할 수 없다.</li>
</ul>
<p><br /></p>
<h4 id="1---cons-list-construction-list">(1) 리스트 생성자 (cons list, construction list)</h4>
<ul>
<li>콘스 리스트는 리스프(Lisp) 언어에 도입된 데이터 구조다.</li>
<li>하나의 값과 값의 쌍으로 구성된 두 인수를 이용해 새로운 쌍을 생성한다.</li>
<li>함수형 프로그래밍에서 은어적으로, <code>x를 y에 콘스한다</code>고 하는데 원소 x를 y 리스트의 첫 부분에 추가해서 새로운 리스트를 생성한다는 의미이다.</li>
<li>러스트는 콘스 리스트보다는 보편적으로 Vec<T>를 더 많이 사용한다.</li>
<li>하지만 콘스 리스트를 이해하면 박스를 이용해 어렵지 않게 재귀 데이터 타입을 다룰 수 있다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
    Cons(<span style="color:#66d9ef">i32</span>, List),
    Nil,
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::List::{Cons, Nil};

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> list <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">1</span>, Cons(<span style="color:#ae81ff">2</span>, Cons(<span style="color:#ae81ff">3</span>, Nil)));
}
</code></pre></div><ul>
<li><code>Nil</code>은 재귀의 기본 상태(base case)를 뜻하며, null과는 다르다.</li>
<li>List는 i32 값의 콘스 리스트인 enum이다.</li>
<li>List enum을 이용해 1, 2, 3을 리스트에 저장한다.</li>
<li>위 코드는 에러를 발생시킨다.<br />
<em>error[E0072]: recursive type <code>List</code> has infinite size</em>
<ul>
<li><strong>선언한 List가 재귀 타입이므로 러스트는 어느 정도의 메모리 공간이 필요한지 알 수 없다.</strong></li>
</ul>
</li>
</ul>
<p><br /></p>
<h4 id="2-----">(2) 비재귀 타입의 크기를 계산하는 방법</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">Message</span> {
    Quit,
    Move { x: <span style="color:#66d9ef">i32</span>, y: <span style="color:#66d9ef">i32</span> },
    Write(String),
    ChangeColor(<span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>, <span style="color:#66d9ef">i32</span>),
}
</code></pre></div><ul>
<li>러스트는 Message 값을 저장하는 데 필요한 공간을 결정하기 위해 모든 열거값을 확인한다.</li>
<li>이때 Message 값에 필요한 공간은 가장 큰 열거값을 저장하는 데 필요한 공간이다.</li>
<li>이와는 달리 위의 List 같은 재귀 타입은 아래의 일들이 일어난다.
<ul>
<li>(1) 컴파일러는 Cons 열거값을 먼저 확인한다.</li>
<li>(2) 이 열거값은 i32 타입과 List 타입의 값을 저장한다.</li>
<li>(3) 따라서 Cons는 i32 타입 크기에 List 타입 크기를 더한 공간이 필요하다.</li>
<li>(4) List는 필요 공간을 확인하기 위해 다시 Cons 열거값을 확인한다.</li>
<li>위 과정이 무한반복된다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h4 id="3-boxt----">(3) Box<T>로 재귀 타입의 크기 결정하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// (1)
</span><span style="color:#75715e"></span>help: <span style="color:#a6e22e">insert</span> some indirection (e.g., a <span style="color:#960050;background-color:#1e0010">`</span>Box<span style="color:#960050;background-color:#1e0010">`</span>, <span style="color:#960050;background-color:#1e0010">`</span>Rc<span style="color:#960050;background-color:#1e0010">`</span>, or <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">`</span>) to make <span style="color:#960050;background-color:#1e0010">`</span>List<span style="color:#960050;background-color:#1e0010">`</span> representable
  <span style="color:#f92672">|</span>
<span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span>     Cons(<span style="color:#66d9ef">i32</span>, Box<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
  <span style="color:#f92672">|</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// (2)
</span><span style="color:#75715e"></span><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
    Cons(<span style="color:#66d9ef">i32</span>, Box<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
    Nil,
}

<span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::List::{Cons, Nil};

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> list <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">1</span>, Box::new(Cons(<span style="color:#ae81ff">2</span>, Box::new(Cons(<span style="color:#ae81ff">3</span>, Box::new(Nil))))));
}
</code></pre></div><ul>
<li>러스트 컴파일러는 List 타입에 대한 에러를 내며 위와 같은 유용한 정보를 함께 제공한다.</li>
<li>(1)의 메시지는 값을 직접 저장하지 말고, 가리키는 포인터를 통해 간접적으로 저장하라고 알려준다.</li>
<li>Box<T>는 포인터이고, 포인터의 크기는 가리키는 데이터의 크기와는 무관하다.</li>
<li>(2)의 Cons 열거값은 이제 i32 타입의 크기에 박스의 포인터 데이터를 저장할 공간만 있으면 된다.</li>
<li><strong>List 값에 필요한 메모리 공간은 (i32 크기 + 박스의 포인터 데이터 크기)이다.</strong></li>
<li>Box의 크기는 <a href="https://doc.rust-lang.org/std/primitive.usize.html">usize</a>로, List enum의 크기는 더 이상 무한하지 않다.</li>
</ul>
<p><br /></p>
<hr />
<h2 id="2-deref-----">2. <code>Deref</code> 트레이트로 스마트 포인터를 참조처럼 취급하기</h2>
<ul>
<li>해당 트레이트를 구현하면
<ul>
<li>역참조 연산자(*)의 동작을 변경할 수 있다.</li>
<li>참조를 사용하는 코드를 그대로 스마트 포인터에도 적용할 수 있다.</li>
</ul>
</li>
<li>이를 위해 역참조 연산자가 참조를 어떻게 처리하는지부터 알아야 한다.</li>
</ul>
<p><br /></p>
<h3 id="2-1------">2-1. 역참조 연산자로 포인터가 가리키는 값 읽어오기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>x;

    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, x);
    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, <span style="color:#f92672">*</span>y);
}
</code></pre></div><ul>
<li>변수 x는 i32 값 5를 저장하고, y는 x의 참조를 저장한다.</li>
<li><strong>변수 y를 검증하려면 역참조 연산자를 붙여서 가리키는 값의 참조를 따라가야 한다.</strong></li>
<li>따라서 *y를 통해 y가 가리키는 값 5에 접근할 수 있다.</li>
<li>만약 <code>assert_eq!(5, y)</code>라고 작성하면 에러를 낸다.<br />
<em>error[E0277]: can't compare <code>{integer}</code> with <code>&amp;{integer}</code></em>
<ul>
<li>숫자와 숫자에 대한 참조는 다른 타입이므로 둘을 비교할 수 없기 때문이다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="2-2-boxt--">2-2. Box<T>를 참조처럼 사용하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> Box::new(x);

    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, x);
    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, <span style="color:#f92672">*</span>y);
}
</code></pre></div><ul>
<li>참조 대신 박스를 사용할 수도 있으며, 이때도 역참조 연산자는 정상 동작한다.</li>
<li>박스 타입을 직접 구현하면서 박스가 어떻게 역참조 연산자를 지원하는지 알아보아야 한다.</li>
</ul>
<p><br /></p>
<h3 id="2-3----">2-3. 직접 구현하는 스마트 포인터</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(T);

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> MyBox<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(x: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
        MyBox(x)
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {}
</code></pre></div><ul>
<li><code>Box&lt;T&gt;</code> 와 비슷한 동작은 갖는 스마트 포인터를 구현해보자.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(T);

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> MyBox<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(x: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
        MyBox(x)
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> MyBox::new(x);

    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, x);
    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, <span style="color:#f92672">*</span>y);
}

<span style="color:#75715e">// 실행결과
</span><span style="color:#75715e"></span><span style="color:#75715e">$</span> cargo run
   Compiling deref<span style="color:#f92672">-</span>example v0.<span style="color:#ae81ff">1.0</span> (file:<span style="color:#e6db74">///projects/deref-example)
</span><span style="color:#e6db74"></span>error[E0614]: <span style="color:#a6e22e">type</span> <span style="color:#960050;background-color:#1e0010">`</span>MyBox<span style="color:#f92672">&lt;</span>{integer}<span style="color:#f92672">&gt;</span><span style="color:#960050;background-color:#1e0010">`</span> cannot be dereferenced
  <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">14</span>:<span style="color:#ae81ff">19</span>
   <span style="color:#f92672">|</span>
<span style="color:#ae81ff">14</span> <span style="color:#f92672">|</span>     assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, <span style="color:#f92672">*</span>y);
   <span style="color:#f92672">|</span>                   <span style="color:#f92672">^</span><span style="color:#f92672">^</span>

For more information about this error, try <span style="color:#960050;background-color:#1e0010">`</span>rustc <span style="color:#f92672">-</span><span style="color:#f92672">-</span>explain E0614<span style="color:#960050;background-color:#1e0010">`</span>.
error: <span style="color:#a6e22e">could</span> not compile <span style="color:#960050;background-color:#1e0010">`</span>deref<span style="color:#f92672">-</span>example<span style="color:#960050;background-color:#1e0010">`</span> due to previous error
</code></pre></div><ul>
<li><code>MyBox</code> 구조체는 아직 <code>Deref</code> 트레이트를 구현하지 않았기 때문에, 역참조가 발생하면 오류가 난다.</li>
<li>실제로 Rust 컴파일러는 <code>*y</code>_ 를 <code>_(y.deref())</code> 로 변환하여 실행한다.</li>
</ul>
<p><br /></p>
<h3 id="2-4-deref----">2-4. Deref 트레이트로 참조같은 타입 구현하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::ops::Deref;

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Deref <span style="color:#66d9ef">for</span> MyBox<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Target</span> <span style="color:#f92672">=</span> T;

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">Self</span>::Target {
        <span style="color:#f92672">&amp;</span>self.<span style="color:#ae81ff">0</span>
    }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(T);

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> MyBox<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(x: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
        MyBox(x)
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> MyBox::new(x);

    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, x);
    assert_eq<span style="color:#f92672">!</span>(<span style="color:#ae81ff">5</span>, <span style="color:#f92672">*</span>y);
}
</code></pre></div><ul>
<li><code>Deref</code> 트레이트의 <code>deref()</code> 메서드를 구현하여 역참조 기능을 구현할 수 있다.</li>
<li><code>Deref</code> 트레이트는 표준 라이브러리에서 불러온다.</li>
<li><code>type Target = T;</code> 연관 타입이다. (Ch. 19)</li>
<li><code>deref()</code> 메서드는 <code>&amp;Self::Target</code> 타입 (참조 타입)을 반환한다.</li>
<li><code>&amp;self.0</code>는 튜플 구조체의 첫번째 아이템을 반환한다.</li>
</ul>
<p><br /></p>
<h3 id="2-5-----">2-5. 함수와 메서드에서 묵시적 강제 역참조</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::ops::Deref;

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Deref <span style="color:#66d9ef">for</span> MyBox<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Target</span> <span style="color:#f92672">=</span> T;

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">deref</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">T</span> {
        <span style="color:#f92672">&amp;</span>self.<span style="color:#ae81ff">0</span>
    }
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span>(T);

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> MyBox<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(x: <span style="color:#a6e22e">T</span>) -&gt; <span style="color:#a6e22e">MyBox</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
        MyBox(x)
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hello</span>(name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Hello, {}!&#34;</span>, name);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> m <span style="color:#f92672">=</span> MyBox::new(String::from(<span style="color:#e6db74">&#34;Rust&#34;</span>));
    hello(<span style="color:#f92672">&amp;</span>m);
}
</code></pre></div><ul>
<li>강제 역참조(Deref coercion)란 <code>Deref</code> 트레이트를 구현하는 참조 타입을 다른 타입으로 변환하는 것이다.</li>
<li>위는 <code>&amp;MyBox</code> → <code>&amp;str</code> 변환하는 강제 역참조의 예시이다.
<ul>
<li><code>Deref</code> 트레이트를 구현한 <code>MyBox</code></li>
<li><code>MyBox::deref()</code> 함수가 <code>String</code> 반환</li>
<li><code>Deref</code> 트레이트를 구현한 <code>String</code></li>
<li><code>String::deref()</code> 함수가 <code>str</code> 반환</li>
<li><strong>&amp;m → &amp;String → &amp;str</strong></li>
</ul>
</li>
</ul>
<p><br /></p>
<h4 id="--">[강제 역참조가 없었다면?]</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> m <span style="color:#f92672">=</span> MyBox::new(String::from(<span style="color:#e6db74">&#34;Rust&#34;</span>));
    hello(<span style="color:#f92672">&amp;</span>(<span style="color:#f92672">*</span>m)[..]);
}
</code></pre></div><ul>
<li>가독성이 매우 떨어진다.</li>
</ul>
<p><br /></p>
<h3 id="2-6---">2-6. 강제 역참조와 가변성</h3>
<ul>
<li>불변참조에 <code>Deref</code> 트레이트를 사용했던 것처럼 가변참조에는 <code>DerefMut</code> 를 사용할 수 있다.</li>
<li>Rust 는 3가지 경우에 대한 강제 역참조를 수행한다.
<ul>
<li><code>T: Deref&lt;Target = U&gt;</code> 일 때, <code>&amp;T</code> → <code>&amp;U</code></li>
<li><code>T: DerefMut&lt;Target = U&gt;</code> 일 때, <code>&amp;mut T</code> → <code>&amp;mut U</code></li>
<li><code>T: Deref&lt;Target = U&gt;</code> 일 때, <code>&amp;mut T</code> → <code>&amp;U</code></li>
</ul>
</li>
<li>1, 2 번째는 불변/가변 참조끼리의 강제 역참조이다.</li>
<li>3번째는 <strong>가변→불변</strong>으로의 강제 역참조인데 이는 <strong>단방향으로써 참조 규칙을 위반하지 않기 위해서</strong>이다.</li>
</ul>
<p><br /></p>
<h4 id="---">[다시 살펴보는 참조 규칙]</h4>
<ul>
<li>항상 하나의 가변참조, 혹은 다수의 불변 참조만 있어야 한다.</li>
<li>참조 변수는 항상 유효해야 한다.</li>
</ul>
<p><br /></p>
<h2 id="3-drop----">3. Drop 트레이트로 클린업 코드 실행하기</h2>
<ul>
<li><code>Drop</code> 트레이트는 스마트 포인터가 <strong>스코프 밖으로 나갈때</strong> 클린업 작업을 실행한다.</li>
<li>ex) 파일이나 네트워크 연결시에 후작업을 하여 메모리나 다른 리소스를 해제하여 프로세스 과부하가 발생하지 않게 한다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CustomSmartPointer</span> {
    data: String,
}

<span style="color:#66d9ef">impl</span> Drop <span style="color:#66d9ef">for</span> CustomSmartPointer {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">drop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Dropping CustomSmartPointer with data `{}`!&#34;</span>, self.data);
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> CustomSmartPointer {
        data: String::from(<span style="color:#e6db74">&#34;my stuff&#34;</span>),
    };
    <span style="color:#66d9ef">let</span> d <span style="color:#f92672">=</span> CustomSmartPointer {
        data: String::from(<span style="color:#e6db74">&#34;other stuff&#34;</span>),
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CustomSmartPointers created.&#34;</span>);
}

<span style="color:#75715e">// 실행결과
</span><span style="color:#75715e"></span><span style="color:#75715e">$</span> cargo run
   Compiling drop<span style="color:#f92672">-</span>example v0.<span style="color:#ae81ff">1.0</span> (file:<span style="color:#e6db74">///projects/drop-example)
</span><span style="color:#e6db74"></span>    Finished dev [unoptimized <span style="color:#f92672">+</span> debuginfo] target(s) <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.60</span>s
     Running <span style="color:#960050;background-color:#1e0010">`</span>target<span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>drop<span style="color:#f92672">-</span>example<span style="color:#960050;background-color:#1e0010">`</span>
CustomSmartPointers created.
Dropping CustomSmartPointer with data <span style="color:#960050;background-color:#1e0010">`</span>other stuff<span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">!</span>
Dropping CustomSmartPointer with data <span style="color:#960050;background-color:#1e0010">`</span>my stuff<span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">!</span>
</code></pre></div><ul>
<li><code>Drop</code> 트레이트의 <code>drop</code> 메서드 내부에 클린업 로직을 구현했다.</li>
<li>c, d 포인터가 스코프 밖으로 나갈때 d, c 순으로 drop 메서드를 호출한다.</li>
</ul>
<p><br /></p>
<h3 id="3-1-stdmemdrop---">3-1. <code>std::mem::drop</code> 으로 조기 해제하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CustomSmartPointer</span> {
    data: String,
}

<span style="color:#66d9ef">impl</span> Drop <span style="color:#66d9ef">for</span> CustomSmartPointer {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">drop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Dropping CustomSmartPointer with data `{}`!&#34;</span>, self.data);
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> CustomSmartPointer {
        data: String::from(<span style="color:#e6db74">&#34;some data&#34;</span>),
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CustomSmartPointer created.&#34;</span>);
    c.drop();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CustomSmartPointer dropped before the end of main.&#34;</span>);
}

<span style="color:#75715e">// 실행결과
</span><span style="color:#75715e"></span><span style="color:#75715e">$</span> cargo run
   Compiling drop<span style="color:#f92672">-</span>example v0.<span style="color:#ae81ff">1.0</span> (file:<span style="color:#e6db74">///projects/drop-example)
</span><span style="color:#e6db74"></span>error[E0040]: <span style="color:#a6e22e">explicit</span> <span style="color:#66d9ef">use</span> of destructor method
  <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">16</span>:<span style="color:#ae81ff">7</span>
   <span style="color:#f92672">|</span>
<span style="color:#ae81ff">16</span> <span style="color:#f92672">|</span>     c.drop();
   <span style="color:#f92672">|</span>     <span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span>
   <span style="color:#f92672">|</span>     <span style="color:#f92672">|</span> <span style="color:#f92672">|</span>
   <span style="color:#f92672">|</span>     <span style="color:#f92672">|</span> explicit destructor calls not allowed
   <span style="color:#f92672">|</span>     help: <span style="color:#a6e22e">consider</span> using <span style="color:#960050;background-color:#1e0010">`</span>drop<span style="color:#960050;background-color:#1e0010">`</span> function: <span style="color:#960050;background-color:#1e0010">`</span>drop(c)<span style="color:#960050;background-color:#1e0010">`</span>

For more information about this error, try <span style="color:#960050;background-color:#1e0010">`</span>rustc <span style="color:#f92672">-</span><span style="color:#f92672">-</span>explain E0040<span style="color:#960050;background-color:#1e0010">`</span>.
error: <span style="color:#a6e22e">could</span> not compile <span style="color:#960050;background-color:#1e0010">`</span>drop<span style="color:#f92672">-</span>example<span style="color:#960050;background-color:#1e0010">`</span> due to previous error
</code></pre></div><ul>
<li><code>drop</code> 을 강제로 조기에 호출해야할 경우가 있다.<br />
<em>ex) 스레드 락을 강제적으로 풀어야 할 때</em></li>
<li>이때 drop 을 직접적으로 호출하려 하면 아래의 오류 같이 나타난다.</li>
<li>따라서 수동으로 해제를 하고 싶을때는 <code>std::mem::drop</code> 을 호출하면 된다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">CustomSmartPointer</span> {
    data: String,
}

<span style="color:#66d9ef">impl</span> Drop <span style="color:#66d9ef">for</span> CustomSmartPointer {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">drop</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Dropping CustomSmartPointer with data `{}`!&#34;</span>, self.data);
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> CustomSmartPointer {
        data: String::from(<span style="color:#e6db74">&#34;some data&#34;</span>),
    };
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CustomSmartPointer created.&#34;</span>);
    drop(c);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;CustomSmartPointer dropped before the end of main.&#34;</span>);
}

<span style="color:#75715e">// 실행결과
</span><span style="color:#75715e"></span><span style="color:#75715e">$</span> cargo run
   Compiling drop<span style="color:#f92672">-</span>example v0.<span style="color:#ae81ff">1.0</span> (file:<span style="color:#e6db74">///projects/drop-example)
</span><span style="color:#e6db74"></span>    Finished dev [unoptimized <span style="color:#f92672">+</span> debuginfo] target(s) <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.73</span>s
     Running <span style="color:#960050;background-color:#1e0010">`</span>target<span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>drop<span style="color:#f92672">-</span>example<span style="color:#960050;background-color:#1e0010">`</span>
CustomSmartPointer created.
Dropping CustomSmartPointer with data <span style="color:#960050;background-color:#1e0010">`</span>some data<span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">!</span>
CustomSmartPointer dropped before the end of main.
</code></pre></div><ul>
<li>기존 스코프와 마찬가지로 drop 된 포인터는 더이상 유효하지 않다.</li>
<li>따라서 만약에 실수로 사용될 시, 컴파일러 검사에서 걸리게 된다.</li>
<li>JavaScript (혹은 Garbage Collector 를 사용하는 언어)는 <code>delete</code> 키워드로 객체의 속성을 삭제해도 클린업 실행시점을 예측 할 수가 없다.<br />
<em>GC 만의 로직으로 GC 가 실행될때 클린업이 되기 때문에</em></li>
</ul>
<p><br /></p>
<hr />
<h2 id="4-rct----">4. Rc<T>, 참조 카운터 스마트 포인터</h2>
<ul>
<li>하나의 값을 여러 변수가 소유하는 때는 값에 대한 해제가 어렵다.
<ul>
<li>ex) 그래프에서 여러 엣지가 같은 노드를 가리킬 때</li>
<li>이 노드는 자신을 가리키는 엣지가 모두 사라질 때까지 해제할 수 없다.</li>
</ul>
</li>
<li>러스트는 다중 소유권을 위해 참조 카운터(reference counting) <code>Rc&lt;T&gt;</code> 타입을 지원한다.</li>
<li>Rc<T> 타입은 프로그램의 여러 부분에서 데이터를 읽을 수 있게 힙 메모리에 저장할 때 사용한다.</li>
</ul>
<p><br /></p>
<h3 id="4-1-rct----">4-1. Rc<T> 타입을 이용해 데이터 공유하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
    Cons(<span style="color:#66d9ef">i32</span>, Box<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
    Nil,
}

<span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::List::{Cons, Nil};

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">5</span>, Box::new(Cons(<span style="color:#ae81ff">10</span>, Box::new(Nil))));
    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">3</span>, Box::new(a));
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">4</span>, Box::new(a));
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">$</span> cargo run
   Compiling cons<span style="color:#f92672">-</span>list v0.<span style="color:#ae81ff">1.0</span> (file:<span style="color:#e6db74">///projects/cons-list)
</span><span style="color:#e6db74"></span>error[E0382]: <span style="color:#a6e22e">use</span> of moved value: <span style="color:#960050;background-color:#1e0010">`</span>a<span style="color:#960050;background-color:#1e0010">`</span>
  <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">11</span>:<span style="color:#ae81ff">30</span>
   <span style="color:#f92672">|</span>
<span style="color:#ae81ff">9</span>  <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">5</span>, Box::new(Cons(<span style="color:#ae81ff">10</span>, Box::new(Nil))));
   <span style="color:#f92672">|</span>         <span style="color:#f92672">-</span> <span style="color:#66d9ef">move</span> occurs because <span style="color:#960050;background-color:#1e0010">`</span>a<span style="color:#960050;background-color:#1e0010">`</span> has <span style="color:#66d9ef">type</span> <span style="color:#960050;background-color:#1e0010">`</span>List<span style="color:#960050;background-color:#1e0010">`</span>, which does not implement the <span style="color:#960050;background-color:#1e0010">`</span>Copy<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#66d9ef">trait</span>
<span style="color:#ae81ff">10</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">3</span>, Box::new(a));
   <span style="color:#f92672">|</span>                              <span style="color:#f92672">-</span> value moved here
<span style="color:#ae81ff">11</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">4</span>, Box::new(a));
   <span style="color:#f92672">|</span>                              <span style="color:#f92672">^</span> value used here after <span style="color:#66d9ef">move</span>

For more information about this error, try <span style="color:#960050;background-color:#1e0010">`</span>rustc <span style="color:#f92672">-</span><span style="color:#f92672">-</span>explain E0382<span style="color:#960050;background-color:#1e0010">`</span>.
error: <span style="color:#a6e22e">could</span> not compile <span style="color:#960050;background-color:#1e0010">`</span>cons<span style="color:#f92672">-</span>list<span style="color:#960050;background-color:#1e0010">`</span> due to previous error
</code></pre></div><ul>
<li>Cons 열거값은 자신이 저장한 데이터를 소유하고 있다.</li>
<li>따라서 b 리스트를 생성할 때 a가 b로 이동하여 b가 a를 소유한다.</li>
<li>그래서 c 리스트를 생성하는 코드는 a가 이미 이동했으므로 동작하지 않는다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
    Cons(<span style="color:#66d9ef">i32</span>, Rc<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
    Nil,
}

<span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::List::{Cons, Nil};
<span style="color:#66d9ef">use</span> std::rc::Rc;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Rc::new(Cons(<span style="color:#ae81ff">5</span>, Rc::new(Cons(<span style="color:#ae81ff">10</span>, Rc::new(Nil)))));
    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">3</span>, Rc::clone(<span style="color:#f92672">&amp;</span>a));
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">4</span>, Rc::clone(<span style="color:#f92672">&amp;</span>a));
}
</code></pre></div><ul>
<li>Box<T> 대신 Rc<T> 타입을 사용해 b를 생성할 때 a가 가지고 있는 Rc<List>를 복제한다.</li>
<li>이를 통해 참조의 개수가 2개로 늘어나 <strong>a와 b가 Rc<List>의 데이터에 대한 소유권을 공유한다.</strong></li>
<li>c를 생성할 때도 복제가 발생해 참조 개수가 3개로 늘어나게 된다.</li>
<li><strong>즉, Rc::clone을 호출할 때마다 Rc<List> 데이터에 대한 참조 카운트가 증가한다.</strong></li>
<li><strong>참조가 모두 사라질 때까지 데이터는 해제되지 않는다.</strong></li>
<li>Rc::clone(&amp;a) 대신 a.clone()을 호출해도 되나, 전자가 러스트의 관례다.
<ul>
<li>Rc::clone 함수는 대부분 타입이 지원하는 clone 메서드처럼 깊은 복사를 수행하지 않는다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="4-2-rct----">4-2. Rc<T>의 복제는 참조 카운트를 증가시킨다.</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Rc::new(Cons(<span style="color:#ae81ff">5</span>, Rc::new(Cons(<span style="color:#ae81ff">10</span>, Rc::new(Nil)))));
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;count after creating a = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">3</span>, Rc::clone(<span style="color:#f92672">&amp;</span>a));
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;count after creating b = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
    {
        <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> Cons(<span style="color:#ae81ff">4</span>, Rc::clone(<span style="color:#f92672">&amp;</span>a));
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;count after creating c = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
    }
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;count after c goes out of scope = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
}
</code></pre></div><ul>
<li>참조 카운트를 얻는 함수명이 <code>strong_count</code>인 이유는 <code>weak_count</code> 함수도 제공하기 때문이다.</li>
<li>위 코드는 clone 함수를 호출할 때마다 카운트가 1씩 증가한다.</li>
<li>c가 스코프를 벗어나면 1 감소한다.</li>
<li>Drop 트레이트는 Rc<T> 값이 스코프를 벗어나면 자동으로 참조 카운트를 감소한다.</li>
<li><strong>Rc<T>는 불변 참조를 통해 프로그램의 여러 부분에서 공유하는 데이터의 값을 읽을 수 있게 한다.</strong></li>
</ul>
<p><br /></p>
<hr />
<h2 id="5-refcellt----">5. RefCell<T> 타입과 내부 가변성 패턴</h2>
<ul>
<li>내부 가변성(Interior mutability)
<ul>
<li>러스트가 데이터의 불변 참조를 이용해서 데이터를 가공할 수 있게 지원하는 디자인 패턴이다.</li>
<li>즉, 불변 값 안에 저장된 값을 변경하는 패턴이다.</li>
<li>데이터 구조 안에 unsafe 코드를 사용해 러스트의 규칙을 우회한다.</li>
<li>컴파일러가 보장하지 못해도, 런타임에 대여 규칙 적용이 확실하다면 이 패턴을 활용하자.</li>
<li>이때 unsafe 코드는 안전한 API로 감싸지게 되어, 밖에서는 여전히 불변하다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="5-1-refcellt-----">5-1. RefCell<T> 타입으로 런타임에 대여 규칙 강제하기</h3>
<ul>
<li>Rc<T>와 달리 자신이 보유한 데이터에 대한 단일 소유권을 표현한다.</li>
<li>참조와 Box<T> 타입은 대여 규칙의 불변성질이 컴파일 타임에 평가된다.</li>
<li>하지만 RefCell<T> 타입은 이 불변성질이 런타임에 적용된다.</li>
<li><strong>따라서 참조는 규칙이 위반되면 컴파일 에러가 발생하지만, RefCell<T>는 패닉을 리턴하고 종료된다.</strong></li>
<li>대여 규칙을 컴파일 적용하면
<ul>
<li>개발 과정에서 모든 분석이 이미 완료되었으므로 런타임 성능 손실이 없다.</li>
<li>대부분 대여 규칙을 컴파일에 확인하는 것이 최선이므로 러스트에서 디폴트인 이유다.</li>
</ul>
</li>
<li>대여 규칙을 런타임 적용하면
<ul>
<li>컴파일타임 검사 때문에 할 수 없던 메모리 안전성 작업을 수행할 수 있다.</li>
<li>ex) 시스템 정지(halting) 문제 - 입력값을 넣었을 때 정지할지 말지</li>
</ul>
</li>
<li>Rc<T> 타입과 마찬가지로 RefCell<T>도 단일 스레드 환경에서만 사용해야 한다.</li>
</ul>
<p><br /></p>
<h3 id="5-2-------">5-2. 내부 가변성: 불변 값에 대한 가변 대여</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
    <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> x;
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">$</span> cargo run
   Compiling borrowing v0.<span style="color:#ae81ff">1.0</span> (file:<span style="color:#e6db74">///projects/borrowing)
</span><span style="color:#e6db74"></span>error[E0596]: <span style="color:#a6e22e">cannot</span> borrow <span style="color:#960050;background-color:#1e0010">`</span>x<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#66d9ef">as</span> mutable, <span style="color:#66d9ef">as</span> it is not declared <span style="color:#66d9ef">as</span> mutable
 <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>main.rs:<span style="color:#ae81ff">3</span>:<span style="color:#ae81ff">13</span>
  <span style="color:#f92672">|</span>
<span style="color:#ae81ff">2</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#ae81ff">5</span>;
  <span style="color:#f92672">|</span>         <span style="color:#f92672">-</span> help: <span style="color:#a6e22e">consider</span> changing this to be mutable: <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#66d9ef">mut</span> x<span style="color:#960050;background-color:#1e0010">`</span>
<span style="color:#ae81ff">3</span> <span style="color:#f92672">|</span>     <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> x;
  <span style="color:#f92672">|</span>             <span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span> cannot borrow <span style="color:#66d9ef">as</span> mutable

For more information about this error, try <span style="color:#960050;background-color:#1e0010">`</span>rustc <span style="color:#f92672">-</span><span style="color:#f92672">-</span>explain E0596<span style="color:#960050;background-color:#1e0010">`</span>.
error: <span style="color:#a6e22e">could</span> not compile <span style="color:#960050;background-color:#1e0010">`</span>borrowing<span style="color:#960050;background-color:#1e0010">`</span> due to previous error
</code></pre></div><ul>
<li>대여 규칙에 따르면 위 코드는 컴파일되지 않는다.</li>
<li>때로는 값을 불변하게 유지하면서 값이 제공하는 메서드를 통해 값을 변경해야할 수도 있다.</li>
<li>이때 RefCell<T>를 사용하며, 이 타입은 대여 규칙을 우회하는 것이 아니다.</li>
</ul>
<p><br /></p>
<h4 id="1-----mock-objects">(1) 내부 가변성의 활용 예: Mock Objects</h4>
<ul>
<li>러스트에는 객체라는 개념이 없어, 표준 라이브러리로 mock 객체를 지원하지 않는다.</li>
<li>따라서 그러한 역할을 하는 구조체를 직접 정의하면 된다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// 현재 값이 최대값에 얼마나 가까워지는지 추적하여
</span><span style="color:#75715e"></span><span style="color:#75715e">// 일정 수준이 되면 경고를 보내는 라이브러리
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Messenger {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span>self, msg: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>);
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LimitTracker</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T: <span style="color:#a6e22e">Messenger</span><span style="color:#f92672">&gt;</span> {
    messenger: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> T,
    value: <span style="color:#66d9ef">usize</span>,
    max: <span style="color:#66d9ef">usize</span>,
}

<span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;</span> LimitTracker<span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;</span>
<span style="color:#66d9ef">where</span>
    T: <span style="color:#a6e22e">Messenger</span>,
{
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(messenger: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> T, max: <span style="color:#66d9ef">usize</span>) -&gt; <span style="color:#a6e22e">LimitTracker</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span>, T<span style="color:#f92672">&gt;</span> {
        LimitTracker {
            messenger,
            value: <span style="color:#ae81ff">0</span>,
            max,
        }
    }

    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">set_value</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self, value: <span style="color:#66d9ef">usize</span>) {
        self.value <span style="color:#f92672">=</span> value;

        <span style="color:#66d9ef">let</span> percentage_of_max <span style="color:#f92672">=</span> self.value <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span> <span style="color:#f92672">/</span> self.max <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f64</span>;

        <span style="color:#66d9ef">if</span> percentage_of_max <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1.0</span> {
            self.messenger.send(<span style="color:#e6db74">&#34;Error: You are over your quota!&#34;</span>);
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> percentage_of_max <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0.9</span> {
            self.messenger
                .send(<span style="color:#e6db74">&#34;Urgent warning: You&#39;ve used up over 90% of your quota!&#34;</span>);
        } <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> percentage_of_max <span style="color:#f92672">&gt;</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">0.75</span> {
            self.messenger
                .send(<span style="color:#e6db74">&#34;Warning: You&#39;ve used up over 75% of your quota!&#34;</span>);
        }
    }
}
</code></pre></div><ul>
<li>Messenger 트레이트의 send 메서드는 mock 객체가 구현해야 할 인터페이스다.</li>
<li>테스트를 위해 원하는 메시지로 send 메서드가 호출되는지 확인할 mock 객체가 필요하다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[</span><span style="color:#75715e">cfg(test)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">mod</span> tests {
    <span style="color:#66d9ef">use</span> <span style="color:#66d9ef">super</span>::<span style="color:#f92672">*</span>;

    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MockMessenger</span> {
        sent_messages: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
    }

    <span style="color:#66d9ef">impl</span> MockMessenger {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">MockMessenger</span> {
            MockMessenger {
                sent_messages: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[],
            }
        }
    }

    <span style="color:#66d9ef">impl</span> Messenger <span style="color:#66d9ef">for</span> MockMessenger {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span>self, message: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
            self.sent_messages.push(String::from(message));
        }
    }

    <span style="color:#75715e">#[</span><span style="color:#75715e">test</span><span style="color:#75715e">]</span>
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">it_sends_an_over_75_percent_warning_message</span>() {
        <span style="color:#66d9ef">let</span> mock_messenger <span style="color:#f92672">=</span> MockMessenger::new();
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> limit_tracker <span style="color:#f92672">=</span> LimitTracker::new(<span style="color:#f92672">&amp;</span>mock_messenger, <span style="color:#ae81ff">100</span>);

        limit_tracker.set_value(<span style="color:#ae81ff">80</span>);

        assert_eq<span style="color:#f92672">!</span>(mock_messenger.sent_messages.len(), <span style="color:#ae81ff">1</span>);
    }
}
</code></pre></div><ul>
<li>이 테스트에서 send 메서드는 매개변수로 전달된 메시지를 sent_messages 리스트에 저장한다.</li>
<li>LimitTracker에 최대값의 75%보다 큰 값을 지정해 테스트하고 있다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">$</span> cargo test
   Compiling limit<span style="color:#f92672">-</span>tracker v0.<span style="color:#ae81ff">1.0</span> (file:<span style="color:#e6db74">///projects/limit-tracker)
</span><span style="color:#e6db74"></span>error[E0596]: <span style="color:#a6e22e">cannot</span> borrow <span style="color:#960050;background-color:#1e0010">`</span>self.sent_messages<span style="color:#960050;background-color:#1e0010">`</span> <span style="color:#66d9ef">as</span> mutable, <span style="color:#66d9ef">as</span> it is behind a <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">`</span> reference
  <span style="color:#f92672">-</span>-&gt; <span style="color:#a6e22e">src</span><span style="color:#f92672">/</span>lib.rs:<span style="color:#ae81ff">58</span>:<span style="color:#ae81ff">13</span>
   <span style="color:#f92672">|</span>
<span style="color:#ae81ff">2</span>  <span style="color:#f92672">|</span>     <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span>self, msg: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>);
   <span style="color:#f92672">|</span>             <span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span> help: <span style="color:#a6e22e">consider</span> changing that to be a mutable reference: <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self<span style="color:#960050;background-color:#1e0010">`</span>
...
<span style="color:#ae81ff">58</span> <span style="color:#f92672">|</span>             self.sent_messages.push(String::from(message));
   <span style="color:#f92672">|</span>             <span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span><span style="color:#f92672">^</span> <span style="color:#960050;background-color:#1e0010">`</span>self<span style="color:#960050;background-color:#1e0010">`</span> is a <span style="color:#960050;background-color:#1e0010">`</span><span style="color:#f92672">&amp;</span><span style="color:#960050;background-color:#1e0010">`</span> reference, so the data it refers to cannot be borrowed <span style="color:#66d9ef">as</span> mutable

For more information about this error, try <span style="color:#960050;background-color:#1e0010">`</span>rustc <span style="color:#f92672">-</span><span style="color:#f92672">-</span>explain E0596<span style="color:#960050;background-color:#1e0010">`</span>.
error: <span style="color:#a6e22e">could</span> not compile <span style="color:#960050;background-color:#1e0010">`</span>limit<span style="color:#f92672">-</span>tracker<span style="color:#960050;background-color:#1e0010">`</span> due to previous error
warning: <span style="color:#a6e22e">build</span> failed, waiting <span style="color:#66d9ef">for</span> other jobs to finish...
error: <span style="color:#a6e22e">build</span> failed
</code></pre></div><ul>
<li>send 메서드는 self에 대한 가변 참조를 받기 때문에 MockMessenger 인스턴스를 변경할 수 없다.</li>
<li>Messenger 트레이트의 send 메서드 시그니처를 변경해야 하므로 &amp;mut self를 사용하기도 힘들다.</li>
<li>이 경우 내부 가변성이 필요하다.</li>
<li>sent_messages 필드를 RefCell<T> 타입으로 선언해보자.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[</span><span style="color:#75715e">cfg(test)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">mod</span> tests {
    <span style="color:#66d9ef">use</span> <span style="color:#66d9ef">super</span>::<span style="color:#f92672">*</span>;
    <span style="color:#66d9ef">use</span> std::cell::RefCell;

    <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MockMessenger</span> {
        sent_messages: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>,
    }

    <span style="color:#66d9ef">impl</span> MockMessenger {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>() -&gt; <span style="color:#a6e22e">MockMessenger</span> {
            MockMessenger {
                sent_messages: <span style="color:#a6e22e">RefCell</span>::new(vec<span style="color:#f92672">!</span>[]),
            }
        }
    }

    <span style="color:#66d9ef">impl</span> Messenger <span style="color:#66d9ef">for</span> MockMessenger {
        <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span>self, message: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
            self.sent_messages.borrow_mut().push(String::from(message));
        }
    }

    <span style="color:#75715e">#[</span><span style="color:#75715e">test</span><span style="color:#75715e">]</span>
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">it_sends_an_over_75_percent_warning_message</span>() {
        <span style="color:#75715e">// --snip--
</span><span style="color:#75715e"></span>
        assert_eq<span style="color:#f92672">!</span>(mock_messenger.sent_messages.borrow().len(), <span style="color:#ae81ff">1</span>);
    }
}
</code></pre></div><ul>
<li>sent_messages 필드는 이제 Vec<String>이 아니라 <code>RefCell&lt;Vec&lt;String&gt;&gt;</code> 타입이다.</li>
<li><strong>RefCell 타입의 borrow 메서드를 호출해 벡터에 대한 불변 참조를 가져와 검증할 수 있다.</strong></li>
</ul>
<p><br /></p>
<h4 id="2-refcellt----">(2) RefCell<T> 이용해 런타임에 대여 검사하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// 같은 스코프에서 두 가변 참조를 생성함
</span><span style="color:#75715e"></span>
<span style="color:#66d9ef">impl</span> Messenger <span style="color:#66d9ef">for</span> MockMessenger {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span>self, message: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> one_borrow <span style="color:#f92672">=</span> self.sent_messages.borrow_mut();
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> two_borrow <span style="color:#f92672">=</span> self.sent_messages.borrow_mut();

        one_borrow.push(String::from(message));
        two_borrow.push(String::from(message));
    }
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">failures:
<span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span> tests::it_sends_an_over_75_percent_warning_message stdout <span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span><span style="color:#f92672">-</span>
thread <span style="color:#a6e22e">&#39;main</span><span style="color:#960050;background-color:#1e0010">&#39;</span> panicked at <span style="color:#a6e22e">&#39;already</span> borrowed: <span style="color:#a6e22e">BorrowMutError</span><span style="color:#960050;background-color:#1e0010">&#39;</span>, src<span style="color:#f92672">/</span>lib.rs:<span style="color:#ae81ff">60</span>:<span style="color:#ae81ff">53</span>
note: <span style="color:#a6e22e">run</span> with <span style="color:#960050;background-color:#1e0010">`</span>RUST_BACKTRACE<span style="color:#f92672">=</span><span style="color:#ae81ff">1</span><span style="color:#960050;background-color:#1e0010">`</span> environment variable to display a backtrace
</code></pre></div><ul>
<li><code>borrow</code> 메서드는 스마트 포인터 타입 Ref<T>를 반환한다.</li>
<li><code>borrow_mut</code> 메서드는 스마트 포인터 타입 RefMut<T>를 반환한다.</li>
<li>모두 Deref 트레이트를 구현하므로 보통의 참조와 같은 방식으로 동작한다.</li>
<li>RefCell<T>은 활성화된 Ref<T>, RefMut<T>의 스마트 포인트 개수를 추적한다.</li>
<li>컴파일타임 대여 규칙과 마찬가지로 어느 한 시점에 다수의 불변 대여나 하나의 가변 대여만 허용한다.</li>
<li>이 규칙을 위반하면 참조에서의 컴파일 에러와 달리 런타임 패닉을 발생한다.</li>
<li>따라서 위 테스트는 대여 규칙 위반 확인을 RefCell<T>에 의해 런타임에 실행하므로 실패한다.</li>
</ul>
<p><br /></p>
<ul>
<li>대여 에러를 런타임에 확인하는 것은 코드상의 실수를 개발 과정에서 발견할 수 없다는 뜻이다.</li>
<li><strong>런타임에서 대여에 대한 회수를 추적하므로 약간의 런타임 성능 손실이 발생할 수도 있다.</strong></li>
<li><strong>하지만 RefCell<T>은 꼭 불변값을 사용해야 할 때도 자신을 변경하는 mock 객체를 작성할 수 있다.</strong></li>
<li><strong>따라서 일반적인 참조보다 더 많은 기능이 필요하면 손실을 감수하고 RefCell<T> 타입을 쓰면 된다.</strong></li>
</ul>
<p><br /></p>
<h3 id="5-3-rct-refcellt------">5-3. Rc<T>와 RefCell<T> 조합해 가변 데이터에 다중 소유권 적용하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[</span><span style="color:#75715e">derive(Debug)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
    Cons(Rc<span style="color:#f92672">&lt;</span>RefCell<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>, Rc<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span>),
    Nil,
}

<span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::List::{Cons, Nil};
<span style="color:#66d9ef">use</span> std::cell::RefCell;
<span style="color:#66d9ef">use</span> std::rc::Rc;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> value <span style="color:#f92672">=</span> Rc::new(RefCell::new(<span style="color:#ae81ff">5</span>));

    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Rc::new(Cons(Rc::clone(<span style="color:#f92672">&amp;</span>value), Rc::new(Nil)));

    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Cons(Rc::new(RefCell::new(<span style="color:#ae81ff">3</span>)), Rc::clone(<span style="color:#f92672">&amp;</span>a));
    <span style="color:#66d9ef">let</span> c <span style="color:#f92672">=</span> Cons(Rc::new(RefCell::new(<span style="color:#ae81ff">4</span>)), Rc::clone(<span style="color:#f92672">&amp;</span>a));

    <span style="color:#f92672">*</span>value.borrow_mut() <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">10</span>;

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;a after = {:?}&#34;</span>, a);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;b after = {:?}&#34;</span>, b);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;c after = {:?}&#34;</span>, c);
}
</code></pre></div><ul>
<li>RC<T>는 데이터에 다중 소유권을 적용하지만, 그 데이터에 대한 불변 접근만 허용한다.</li>
<li><strong>하지만 RC<T>에 RefCell<T>을 저장하면 다중 소유권이 적용된 데이터를 수정할 수도 있다.</strong></li>
<li>위 코드에서 value에서 a로 소유권을 넘기거나 value에서 값을 대여하고 있지 않다.
<ul>
<li><code>clone</code>을 호출해 a와 value 모두 내부 값 5에 대한 소유권을 갖게 한다.</li>
</ul>
</li>
<li><code>borrow_mut</code>를 호출할 때 Rc<T>를 내부 RefCell<T> 값으로 자동 역참조한다.</li>
<li>이제 a, b, c는 모두 15가 출력된다.</li>
<li><strong>RefCell<T>로 외부에서는 불변인 List 값을 생성하지만 borrow 메서드로 데이터를 수정할 수 있다.</strong></li>
<li><strong>trade-off: 런타임에 실행되는 대여 규칙은 데이터 경합을 방지하나(구조의 유연성), 속도를 희생한다.</strong></li>
</ul>
<p><br /></p>
<hr />
<h2 id="6----">6. 순환참조는 메모리 누수를 일으킨다.</h2>
<ul>
<li>아무리 러스트가 메모리 안전성을 보장해도 실수로 메모리를 해제하지 않으면 메모리 누수가 일어난다.</li>
<li>러스트가 컴파일의 데이터 경합을 완전히 막지 않듯이 메모리 누수도 마찬가지다.
<ul>
<li>Rc<T>, RefCell<T>가 메모리 누수를 허용하는 것처럼</li>
<li>서로가 서로를 참조하는 참조를 생성할 수 있다.</li>
<li>그렇게 되면 서로에 대한 참조 카운트가 0이 되지 않으므로 이 값들은 절대 해제되지 않는다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="6-1--">6-1. 순환참조 생성하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> <span style="color:#66d9ef">crate</span>::List::{Cons, Nil};
<span style="color:#66d9ef">use</span> std::cell::RefCell;
<span style="color:#66d9ef">use</span> std::rc::Rc;

<span style="color:#75715e">#[</span><span style="color:#75715e">derive(Debug)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">List</span> {
    Cons(<span style="color:#66d9ef">i32</span>, RefCell<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>),
    Nil,
}

<span style="color:#66d9ef">impl</span> List {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tail</span>(<span style="color:#f92672">&amp;</span>self) -&gt; Option<span style="color:#f92672">&lt;</span><span style="color:#f92672">&amp;</span>RefCell<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>List<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">match</span> self {
            Cons(_, item) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> Some(item),
            Nil <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> None,
        }
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> a <span style="color:#f92672">=</span> Rc::new(Cons(<span style="color:#ae81ff">5</span>, RefCell::new(Rc::new(Nil))));

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;a initial rc count = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;a next item = {:?}&#34;</span>, a.tail());

    <span style="color:#66d9ef">let</span> b <span style="color:#f92672">=</span> Rc::new(Cons(<span style="color:#ae81ff">10</span>, RefCell::new(Rc::clone(<span style="color:#f92672">&amp;</span>a))));

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;a rc count after b creation = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;b initial rc count = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>b));
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;b next item = {:?}&#34;</span>, b.tail());

    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(link) <span style="color:#f92672">=</span> a.tail() {
        <span style="color:#f92672">*</span>link.borrow_mut() <span style="color:#f92672">=</span> Rc::clone(<span style="color:#f92672">&amp;</span>b);
    }

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;b rc count after changing a = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>b));
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;a rc count after changing a = {}&#34;</span>, Rc::strong_count(<span style="color:#f92672">&amp;</span>a));

    <span style="color:#75715e">// 순환참조가 생성된 것을 확인하려면 아래 코드 주석을 해제한다.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 하지만 그러면 스택 오버플로가 발생한다.
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// println!(&#34;a next item = {:?}&#34;, a.tail());
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>List 열거자는 Cons 열거값이 가리키는 List값을 수정할 수 있도록 선언되었다.</li>
<li><code>tail</code> 메서드는 Cons 열거값이 저장된 두 번째 원소에 쉽게 접근하기 위해 선언되었다.</li>
<li>이때 b가 a를 가리키도록 생성하고 a가 다시 b를 가리키도록 하면 순환참조가 생성된다.
<ul>
<li><code>a.tail</code>을 호출해 RefCell&lt;Rc<List>&gt;에 대한 참조를 얻어 link 변수에 저장한다.</li>
<li><code>borrow_mut</code>을 호출해 Rc<List> 안에 저장된 Nil을 b에 저장된 Rc<List> 값으로 변경한다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">$</span> cargo run
   Compiling cons<span style="color:#f92672">-</span>list v0.<span style="color:#ae81ff">1.0</span> (file:<span style="color:#e6db74">///projects/cons-list)
</span><span style="color:#e6db74"></span>    Finished dev [unoptimized <span style="color:#f92672">+</span> debuginfo] target(s) <span style="color:#66d9ef">in</span> <span style="color:#ae81ff">0.53</span>s
     Running <span style="color:#960050;background-color:#1e0010">`</span>target<span style="color:#f92672">/</span>debug<span style="color:#f92672">/</span>cons<span style="color:#f92672">-</span>list<span style="color:#960050;background-color:#1e0010">`</span>
a initial rc count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
a next item <span style="color:#f92672">=</span> Some(RefCell { value: <span style="color:#a6e22e">Nil</span> })
a rc count after b creation <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
b initial rc count <span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>
b next item <span style="color:#f92672">=</span> Some(RefCell { value: <span style="color:#a6e22e">Cons</span>(<span style="color:#ae81ff">5</span>, RefCell { value: <span style="color:#a6e22e">Nil</span> }) })
b rc count after changing a <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
a rc count after changing a <span style="color:#f92672">=</span> <span style="color:#ae81ff">2</span>
</code></pre></div><ul>
<li>a가 b를 가리키도록 변경하면 두 리스트의 Rc<List>에 대한 참조 카운트는 2가 된다.</li>
<li>main 함수 마지막에 b를 해제하면 Rc<List> 참조 카운트는 1로 감소한다.</li>
<li>여전히 a가 b였던 Rc<List>를 참조하고 있으므로 Rc<List>가 저장되었던 힙 메모리는 해제되지 않는다.</li>
<li><strong>따라서 마지막 주석을 해제하면 a가 가리키는 b가 가리키는 a를 출력하려고 하므로 스택 오버플로가 발생한다.</strong></li>
<li>이때 러스트는 순환참조를 생성하는 순간 프로그램을 중단시킨다.</li>
</ul>
<p><br /></p>
<h3 id="6-2---rct--weakt-">6-2. 순환참조 방지: Rc<T> 대신 Weak<T> 활용하기</h3>
<ul>
<li><code>Rc::clone</code>은 Rc<T> 인스턴스의 string_count 값을 증가시키고, 이 값이 0인 인스턴스만 해제한다.</li>
<li><code>Rc::downgrade</code> 메서드는 Rc<T> 인스턴스의 weak_count 값을 증가시키고, 0이 아니어도 해제된다.</li>
<li>강한 참조는 Rc<T> 인스턴스에 대한 소유권을 공유하지만, 약한 참조는 소유권 관계를 표현하지 않는다.</li>
<li>Weak<T> 참조는 언제든 해제될 수 있어서 반드시 가리키는 값이 유효한지 확인해야 한다.</li>
<li>Weak<T>의 <code>upgrade</code> 메서드는 Option<T>를 반환한다.
<ul>
<li><strong>참조하는 값이 해제되지 않았으면 Some&lt;Rc<T>&gt;를 반환하고, 해제되었으면 None을 반환한다.</strong></li>
<li>결과적으로 유효하지 않은 포인터를 잘못 사용하는 상황은 일어나지 않는다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h4 id="1-------">(1) 트리 데이터 구조: 자식 노드를 갖는 노드</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::cell::RefCell;
<span style="color:#66d9ef">use</span> std::rc::Rc;

<span style="color:#75715e">// Node는
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1. 자식 노드에 대한 소유권을 가져야 함
</span><span style="color:#75715e"></span><span style="color:#75715e">// 2. 저장할 변수가 트리의 각 노드에 접근하게 소유권을 변수와 공유해야 함
</span><span style="color:#75715e"></span><span style="color:#75715e">// 3. 각 노드는 다른 노드의 자식 노드를 변경할 수 있어야 함
</span><span style="color:#75715e"></span><span style="color:#75715e">// =&gt; RefCell&lt;Vec&lt;Rc&lt;Node&gt;&gt;&gt;
</span><span style="color:#75715e"></span><span style="color:#75715e">#[</span><span style="color:#75715e">derive(Debug)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
    value: <span style="color:#66d9ef">i32</span>,
    children: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>,
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> leaf <span style="color:#f92672">=</span> Rc::new(Node {
        value: <span style="color:#ae81ff">3</span>,
        children: <span style="color:#a6e22e">RefCell</span>::new(vec<span style="color:#f92672">!</span>[]),
    });

    <span style="color:#66d9ef">let</span> branch <span style="color:#f92672">=</span> Rc::new(Node {
        value: <span style="color:#ae81ff">5</span>,
        children: <span style="color:#a6e22e">RefCell</span>::new(vec<span style="color:#f92672">!</span>[Rc::clone(<span style="color:#f92672">&amp;</span>leaf)]),
    });
}
</code></pre></div><ul>
<li>leaf 안에 저장된 Node는, leaf와 branch 두 인스턴스가 공유하게 된다.</li>
<li>branch.children을 통해 branch를 통해 leaf에 접근할 수 있다.</li>
<li>그러나 leaf는 branch 인스턴스에 대한 참조가 없으므로 접근할 수 없다.</li>
<li>따라서 leaf 인스턴스가 branch 인스턴스를 부모 노드로 인식하게 만들어야 한다.</li>
</ul>
<p><br /></p>
<h4 id="2------">(2) 부모 노드의 참조를 자식 노드에 추가하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::cell::RefCell;
<span style="color:#66d9ef">use</span> std::rc::{Rc, Weak};

<span style="color:#75715e">// parent 필드가 Rc&lt;T&gt; 타입이라면:
</span><span style="color:#75715e"></span><span style="color:#75715e">// 1.leaf.parent는 branch를 가리킴
</span><span style="color:#75715e"></span><span style="color:#75715e">// 2. branch.children은 leaf를 가리킴
</span><span style="color:#75715e"></span><span style="color:#75715e">// =&gt; 순환참조 발생
</span><span style="color:#75715e"></span><span style="color:#75715e">#[</span><span style="color:#75715e">derive(Debug)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Node</span> {
    value: <span style="color:#66d9ef">i32</span>,
    parent: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Weak<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>,
    children: <span style="color:#a6e22e">RefCell</span><span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Rc<span style="color:#f92672">&lt;</span>Node<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span>,
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> leaf <span style="color:#f92672">=</span> Rc::new(Node {
        value: <span style="color:#ae81ff">3</span>,
        parent: <span style="color:#a6e22e">RefCell</span>::new(Weak::new()),
        children: <span style="color:#a6e22e">RefCell</span>::new(vec<span style="color:#f92672">!</span>[]),
    });

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;leaf parent = {:?}&#34;</span>, leaf.parent.borrow().upgrade());

    <span style="color:#66d9ef">let</span> branch <span style="color:#f92672">=</span> Rc::new(Node {
        value: <span style="color:#ae81ff">5</span>,
        parent: <span style="color:#a6e22e">RefCell</span>::new(Weak::new()),
        children: <span style="color:#a6e22e">RefCell</span>::new(vec<span style="color:#f92672">!</span>[Rc::clone(<span style="color:#f92672">&amp;</span>leaf)]),
    });

    <span style="color:#f92672">*</span>leaf.parent.borrow_mut() <span style="color:#f92672">=</span> Rc::downgrade(<span style="color:#f92672">&amp;</span>branch);

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;leaf parent = {:?}&#34;</span>, leaf.parent.borrow().upgrade());
}
</code></pre></div><ul>
<li>부모 노드가 해제되면 자식 노드도 함께 해제되도록 부모 노드는 자식 노드를 소유해야 한다.</li>
<li><strong>자식 노드 하나가 해제되어도 부모 노드는 존재해야 하며, 이 경우가 바로 약한 참조에 해당한다.</strong></li>
<li>따라서 위 코드의 Node는 부모 노드를 참조할 수 있지만 소유하지는 않는다.</li>
<li><code>upgrade</code> 메서드로 leaf 인스턴스의 부모에 대한 참조를 가져오면 None 값이 반환된다.</li>
<li>leaf를 branch의 자식 노드로 대입한 후에는 이제 Some 값이 반환된다.
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">leaf parent <span style="color:#f92672">=</span> Some(Node { value: <span style="color:#ae81ff">5</span>, parent: <span style="color:#a6e22e">RefCell</span> { value: (Weak) },
children: <span style="color:#a6e22e">RefCell</span> { value: [Node { value: <span style="color:#ae81ff">3</span>, parent: <span style="color:#a6e22e">RefCell</span> { value: (Weak) },
children: <span style="color:#a6e22e">RefCell</span> { value: [] } }] } })
</code></pre></div></li>
</ul>
<p><br /></p>
<h4 id="3-strong-count-weak-count--">(3) strong_count와 weak_count 값 확인하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> leaf <span style="color:#f92672">=</span> Rc::new(Node {
        value: <span style="color:#ae81ff">3</span>,
        parent: <span style="color:#a6e22e">RefCell</span>::new(Weak::new()),
        children: <span style="color:#a6e22e">RefCell</span>::new(vec<span style="color:#f92672">!</span>[]),
    });

    <span style="color:#75715e">// leaf strong = 1, weak = 0
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(
        <span style="color:#e6db74">&#34;leaf strong = {}, weak = {}&#34;</span>,
        Rc::strong_count(<span style="color:#f92672">&amp;</span>leaf),
        Rc::weak_count(<span style="color:#f92672">&amp;</span>leaf),
    );

    {
        <span style="color:#66d9ef">let</span> branch <span style="color:#f92672">=</span> Rc::new(Node {
            value: <span style="color:#ae81ff">5</span>,
            parent: <span style="color:#a6e22e">RefCell</span>::new(Weak::new()),
            children: <span style="color:#a6e22e">RefCell</span>::new(vec<span style="color:#f92672">!</span>[Rc::clone(<span style="color:#f92672">&amp;</span>leaf)]),
        });

        <span style="color:#f92672">*</span>leaf.parent.borrow_mut() <span style="color:#f92672">=</span> Rc::downgrade(<span style="color:#f92672">&amp;</span>branch);

        <span style="color:#75715e">// branch strong = 1, weak = 1
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// leaf.parent 필드가 Weak&lt;Node&gt; 타입을 이용해
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// branch 인스턴스를 가리키고 있기 때문임
</span><span style="color:#75715e"></span>        println<span style="color:#f92672">!</span>(
            <span style="color:#e6db74">&#34;branch strong = {}, weak = {}&#34;</span>,
            Rc::strong_count(<span style="color:#f92672">&amp;</span>branch),
            Rc::weak_count(<span style="color:#f92672">&amp;</span>branch),
        );

        <span style="color:#75715e">// leaf strong = 2, weak = 0
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// branch가 leaf 인스턴스에 저장된 Rc&lt;Node&gt; 복제본을
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// branch.children 필드에 저장하고 있어서임
</span><span style="color:#75715e"></span>        println<span style="color:#f92672">!</span>(
            <span style="color:#e6db74">&#34;leaf strong = {}, weak = {}&#34;</span>,
            Rc::strong_count(<span style="color:#f92672">&amp;</span>leaf),
            Rc::weak_count(<span style="color:#f92672">&amp;</span>leaf),
        );
    }

    <span style="color:#75715e">// leaf parent = None
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// branch 인스턴스의 스코프가 끝나므로 Node가 해제되기 때문임
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;leaf parent = {:?}&#34;</span>, leaf.parent.borrow().upgrade());

    <span style="color:#75715e">// leaf strong = 1, weak = 0
</span><span style="color:#75715e"></span>    println<span style="color:#f92672">!</span>(
        <span style="color:#e6db74">&#34;leaf strong = {}, weak = {}&#34;</span>,
        Rc::strong_count(<span style="color:#f92672">&amp;</span>leaf),
        Rc::weak_count(<span style="color:#f92672">&amp;</span>leaf),
    );
}
</code></pre></div><ul>
<li>참조의 수와 값의 해제를 관리하는 모든 코드는 Rc<T>와 Weak<T>에 구현되어 있다.</li>
<li>둘은 모두 Drop 트레이트를 구현하고 있다.</li>
<li><strong>부모와 자식의 관계를 Weak<T> 참조로 표현하면 순환참조 걱정 없이 부모-자식 노드를 참조시킬 수 있다.</strong></li>
</ul>
</div>

</main>

        <footer>
            <p class="copyright text-muted">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>.</p>
        </footer>

        

        
    </body>

</html>

