<!DOCTYPE html>
<html lang="kr-ko">
    <head>
        <meta name="description" content="Functional Language Features: Iterators and Closures" />

<meta name="og:type" content="website" />
<meta property="og:title" content="After reading Rust book chapter 13" />
<meta property="og:site_name" content="After reading Rust book chapter 13" />
<meta property="og:description" content="Functional Language Features: Iterators and Closures" />
<meta property="og:url" content="https://wacilpong.github.io/blog/study/rust/rust-13/" />

<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="After reading Rust book chapter 13" />
<meta name="twitter:description" content="Functional Language Features: Iterators and Closures" />

<meta property="og:image" content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512" />
<meta
  property="twitter:image:src"
  content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512"
/>


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-171393148-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());

  gtag("config", "UA-171393148-1");
</script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>After reading Rust book chapter 13</title>
        
            <link rel="icon" href="https://wacilpong.github.io/blog/favicon.ico">
        
        <style>

    html body {
        font-family: 'Raleway', sans-serif;
        background-color: white;
    }

    :root {
        --accent: #469160;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://wacilpong.github.io/blog/css/main.css">


 <link rel="stylesheet" href="https://wacilpong.github.io/blog/css/custom.css"> 


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.62.0" />
        

        

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">After reading Rust book chapter 13</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/blog/">Home</a></li>
                            
                                <li><a href="/blog/tags/">Category</a></li>
                            
                                <li><a href="/blog/post/">Posts</a></li>
                            
                                <li><a href="/blog/project/">Projects</a></li>
                            
                                <li><a href="/blog/learned/">What I Learned</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wacilpong/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/areum-han-a10645118/"><i class="fa fa-linkedin"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2>After reading Rust book chapter 13</h2>
        <h5></h5>
        
<a href="https://wacilpong.github.io/blog/tags/rust"><kbd class="item-tag">rust</kbd></a>


    </div>

    <div align="start" class="content"><h2 id="closures----">클로저(Closures): 주변 환경을 캡처하는 익명함수</h2>
<ul>
<li><strong>러스트의 클로저는 변수에 저장하거나 다른 함수에 인자로 전달하는 익명함수다.</strong></li>
<li>일반 함수와 달리 클로저는 자신이 정의된 스코프 내의 값들을 캡처한다.</li>
</ul>
<p><br /></p>
<h3 id="1---environment-">(1) 클로저를 이용한 environment 캡처</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// 예시: 무료 셔츠 나눔
</span><span style="color:#75715e"></span><span style="color:#75715e">#[</span><span style="color:#75715e">derive(Debug, PartialEq, Copy, Clone)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ShirtColor</span> {
    Red,
    Blue,
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Inventory</span> {
    shirts: Vec<span style="color:#f92672">&lt;</span>ShirtColor<span style="color:#f92672">&gt;</span>,
}

<span style="color:#66d9ef">impl</span> Inventory {
    <span style="color:#75715e">// 선호하는 색상이 있다면 -&gt; 그 색상 셔츠 나눔
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// 없다면 -&gt; 회사에서 가장 많이 팔리는 셔츠 나눔
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">giveaway</span>(<span style="color:#f92672">&amp;</span>self, user_preference: Option<span style="color:#f92672">&lt;</span>ShirtColor<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">ShirtColor</span> {
        user_preference.unwrap_or_else(<span style="color:#f92672">|</span><span style="color:#f92672">|</span> self.most_stocked())
    }

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">most_stocked</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">ShirtColor</span> {
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num_red <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num_blue <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;

        <span style="color:#66d9ef">for</span> color <span style="color:#66d9ef">in</span> <span style="color:#f92672">&amp;</span>self.shirts {
            <span style="color:#66d9ef">match</span> color {
                ShirtColor::Red <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> num_red <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
                ShirtColor::Blue <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> num_blue <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>,
            }
        }
        <span style="color:#66d9ef">if</span> num_red <span style="color:#f92672">&gt;</span> num_blue {
            ShirtColor::Red
        } <span style="color:#66d9ef">else</span> {
            ShirtColor::Blue
        }
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#75715e">// 파랑 재고가 더 많은 스토어 생성
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> store <span style="color:#f92672">=</span> Inventory {
        shirts: <span style="color:#a6e22e">vec</span><span style="color:#f92672">!</span>[ShirtColor::Blue, ShirtColor::Red, ShirtColor::Blue],
    };

    <span style="color:#75715e">// 선호 색상 빨강
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> user_pref1 <span style="color:#f92672">=</span> Some(ShirtColor::Red);
    <span style="color:#66d9ef">let</span> giveaway1 <span style="color:#f92672">=</span> store.giveaway(user_pref1);
    println<span style="color:#f92672">!</span>(
        <span style="color:#e6db74">&#34;The user with preference {:?} gets {:?}&#34;</span>,
        user_pref1, giveaway1
    );

    <span style="color:#75715e">// 선호 색상 없음
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> user_pref2 <span style="color:#f92672">=</span> None;
    <span style="color:#66d9ef">let</span> giveaway2 <span style="color:#f92672">=</span> store.giveaway(user_pref2);
    println<span style="color:#f92672">!</span>(
        <span style="color:#e6db74">&#34;The user with preference {:?} gets {:?}&#34;</span>,
        user_pref2, giveaway2
    );
}
</code></pre></div><ul>
<li>giveaway 메서드는 unwrap_or_else를 통해 클로저를 사용하고 있다.</li>
<li><a href="https://doc.rust-lang.org/std/option/enum.Option.html#method.unwrap_or_else">unwrap_or_else</a>는 표준 라이브러리에 정의된 <code>Option&lt;T&gt;</code>의 메서드이다.</li>
<li><strong>어떤 인자도 없이 T를 반환하는 클로저</strong>를 인수로 받는다.
<ul>
<li><a href="https://doc.rust-lang.org/std/ops/trait.FnOnce.html"><code>FnOnce</code></a> 트레이트가 구현되어야 하며, 한번만 호출되는 함수이다.</li>
<li><code>|| self.most_stocked()</code> 클로저는 Inventory 인스턴스의 불변 참조를 캡처해 데이터를 패싱한다.</li>
</ul>
</li>
<li>일반함수는 이런 경우에 해당 컨텍스트를 캡처할 수 없다.</li>
<li>vertical pipe(<code>|</code>)로 클로저를 명시하며, <a href="https://wiki.c2.com/?SmalltalkBlocksAndClosures">smalltalk</a>와 <a href="https://www.geeksforgeeks.org/closures-in-ruby/">ruby</a>도 같은 문법이다.</li>
</ul>
<p><br /></p>
<h3 id="2----">(2) 클로저의 타입 추론과 어노테이션</h3>
<ul>
<li>클로저는 일반함수처럼 매개변수와 반환값의 타입을 지정할 필요가 없다.</li>
<li>함수의 타입 어노테이션을 지정하는 이유는 호출할 대상에 노출되는 인터페이스이기 때문이다.</li>
<li>그러나 클로저는 변수에 저장되고 익명인데다 라이브러리 사용자에게 노출되지 않고 사용된다.</li>
<li>따라서 주로 짧고 상대적으로 좁은 컨텍스트에서 실행된다.</li>
<li><strong>컴파일러는 변수의 타입을 추론하는 것과 같은 방법으로 클로저의 매개변수와 반환타입을 추론한다.</strong></li>
</ul>
<p><br /></p>
<h4 id="--">타입을 명시한 클로저</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> expensive_closure <span style="color:#f92672">=</span> <span style="color:#f92672">|</span>num: <span style="color:#66d9ef">u32</span><span style="color:#f92672">|</span> -&gt; <span style="color:#66d9ef">u32</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;calculating slowly...&#34;</span>);
        thread::sleep(Duration::from_secs(<span style="color:#ae81ff">2</span>));
        num
    };
</code></pre></div><ul>
<li>장황한 코드를 작성할 바에는 이렇게 클로저에도 타입 어노테이션을 추가할 수 있다.</li>
<li>함수와 비슷해보이지만 다르다.</li>
</ul>
<p><br /></p>
<h4 id="-">함수와 클로저</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span>  <span style="color:#a6e22e">add_one_v1</span>   (x: <span style="color:#66d9ef">u32</span>) -&gt; <span style="color:#66d9ef">u32</span> { x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> }
<span style="color:#66d9ef">let</span> add_one_v2 <span style="color:#f92672">=</span> <span style="color:#f92672">|</span>x: <span style="color:#66d9ef">u32</span><span style="color:#f92672">|</span> -&gt; <span style="color:#66d9ef">u32</span> { x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> };
<span style="color:#66d9ef">let</span> add_one_v3 <span style="color:#f92672">=</span> <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span>             { x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span> };
<span style="color:#66d9ef">let</span> add_one_v4 <span style="color:#f92672">=</span> <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span>               x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>  ;
</code></pre></div><ul>
<li>v1, 함수의 정의이다.</li>
<li>v2, 타입 어노테이션을 적용한 클로저이다.</li>
<li>v3, 타입 어노테이션을 제거한 클로저이다.</li>
<li>v4, 하나의 표현식으로만 구성되었으므로 괄호를 생략한 클로저이다.</li>
<li>v3과 v4는 컴파일하려면 클로저 호출이 필요한데, 어떻게 사용되는지에 따라 타입이 추론되기 때문이다.</li>
</ul>
<p><br /></p>
<h4 id="----">다른 타입으로 하나의 클로저를 호출하면?</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">let</span> example_closure <span style="color:#f92672">=</span> <span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x;

<span style="color:#66d9ef">let</span> s <span style="color:#f92672">=</span> example_closure(String::from(<span style="color:#e6db74">&#34;hello&#34;</span>));
<span style="color:#66d9ef">let</span> n <span style="color:#f92672">=</span> example_closure(<span style="color:#ae81ff">5</span>);
</code></pre></div><ul>
<li>클로저는 모든 매개변수와 반환값에 대해 하나의 구체화된 타입만 사용한다.</li>
<li>따라서 <strong>String 타입을 인자로 호출했다가 u32 타입을 넣었으므로 에러가 발생한다.</strong><br />
<em>error[E0308]: mismatched types</em></li>
</ul>
<p><br /></p>
<h3 id="3-----">(3) 참조 캡처하기, 혹은 소유권 이동</h3>
<h4 id="borrow">borrow</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// (1) immutable
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> list <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Before defining closure: {:?}&#34;</span>, list);

    <span style="color:#66d9ef">let</span> only_borrows <span style="color:#f92672">=</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;From closure: {:?}&#34;</span>, list);

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Before calling closure: {:?}&#34;</span>, list);
    only_borrows();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;After calling closure: {:?}&#34;</span>, list);
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// (2) mutable
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> list <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Before defining closure: {:?}&#34;</span>, list);

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> borrows_mutably <span style="color:#f92672">=</span> <span style="color:#f92672">|</span><span style="color:#f92672">|</span> list.push(<span style="color:#ae81ff">7</span>);

    <span style="color:#75715e">// 에러: immutable borrow occurs here
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// println!(&#34;After calling closure: {:?}&#34;, list);
</span><span style="color:#75715e"></span>    borrows_mutably();
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;After calling closure: {:?}&#34;</span>, list);
}
</code></pre></div><ul>
<li>list가 println으로 소유권이 이동되어 원칙상 이후에는 사용할 수가 없다.</li>
<li>클로저를 변수에 할당하여 함수처럼 호출할 수도 있다.</li>
<li>(1)은 사용 후에도 출력하기 위해 현재 값들을 불변 차용하여 캡처하는 클로저를 정의한다.</li>
<li>(2)는 list 값을 바꾸므로 가변 차용하여 클로저를 정의한다.</li>
<li>(2)는 borrows_mutably 클로저 선언 후에 가변 차용이 끝난다.</li>
<li>(2)는 즉, 클로저 선언과 호출 사이에 list 값에 대한 사용은 불변 차용이다.</li>
</ul>
<h4 id="move">move</h4>
<ul>
<li>클로저가 환경에서 사용하는 값의 소유권을 강제로 가져오려면 매개변수 앞에 <code>move</code> 키워드를 붙인다.</li>
<li>클로저를 새 스레드에 전달하고 데이터를 이동시켜 새 스레드가 소유하도록 할 때 유용하다.<br />
<em>동시성에 대해 이야기하는 16장에서 자세히 다룰 것</em></li>
</ul>
<p><br /></p>
<h3 id="4--fn-traits---">(4) 클로저와 <code>Fn</code> Traits로부터 캡쳐한 값들 이동시키기</h3>
<h4 id="-----1">클로저가 구현할 수 있는 트레이트</h4>
<ul>
<li>클로저에서는
<ul>
<li>캡처된 값을 클로저 외부로 이동할 수 있다.</li>
<li>캡처된 값을 변경할 수 있다.</li>
<li>캡처된 값에 대해 아무것도 하지 않을 수도 있다.</li>
</ul>
</li>
<li>클로저가 환경의 값을 캡처/처리하는 방식은 클로저가 구현하는 trait와 연관이 있다.</li>
<li>클로저의 trait들은 함수와 구조체가 사용할 수 있는 클로저의 종류를 지정하는 방법이다.
<ul>
<li><code>FnOnce</code>:
<ul>
<li>같은 범위에 선언된 변수를 사용할 수 있으며, 이 범위가 클로저의 environment이다.</li>
<li>클로저는 캡처된 변수를 사용하려면 꼭 이 변수들의 소유권을 가져야 한다.</li>
<li>이 트레이트는 한번만 호출된다, 즉 같은 값에 대한 소유권을 오직 한 번만 가진다.</li>
</ul>
</li>
<li><code>FnMut</code>
<ul>
<li>환경에서 값을 가변 차용한다.</li>
<li>환경에서 캡처한 값을 변경할 수 있고, N번 호출할 수 있다.</li>
</ul>
</li>
<li><code>Fn</code>
<ul>
<li>환경에서 값을 불변 차용한다.</li>
<li>환경을 변경하지 않고 N번 호출할 수 있어, 클로저를 여러 번 호출하는 경우 유용하다.</li>
<li>환경에서 아무것도 캡처하지 않는 클로저는 이 트레이트를 구현한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><br /></p>
<h4 id="1-fnonce">예시1: FnOnce</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span><span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> Option<span style="color:#f92672">&lt;</span>T<span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">unwrap_or_else</span><span style="color:#f92672">&lt;</span>F<span style="color:#f92672">&gt;</span>(self, f: <span style="color:#a6e22e">F</span>) -&gt; <span style="color:#a6e22e">T</span>
    <span style="color:#66d9ef">where</span>
        F: FnOnce() -&gt; <span style="color:#a6e22e">T</span>
    {
        <span style="color:#66d9ef">match</span> self {
            Some(x) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> x,
            None <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> f(),
        }
    }
}
</code></pre></div><ul>
<li>Option<T>의 unwrap_or_else 메서드는 None 경우에 <code>FnOnce() -&gt; T</code> 타입을 반환한다.</li>
<li>즉, 지정된 F는 최소한 한 번은 호출될 수 있어야 하고 인수를 사용하지 않고 T를 반환해야 한다.</li>
<li>모든 클로저는 <code>FnOnce</code>를 구현하므로 이 메서드는 가장 다양한 종류의 클로저를 허용하는 셈이다.</li>
<li>참고로 일반 함수는 세 가지 Fn 트레이트를 모두 구현할 수 있다.
<ul>
<li>따라서 환경에서 값을 캡처할 필요가 없다면 함수를 사용해도 된다.</li>
<li><code>Option&lt;Vec&lt;T&gt;&gt;</code>값이 None이면 <code>unwrap_or_else(Vec::new)</code>를 호출해 빈 벡터를 얻을 수 있다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h4 id="2-fnmut">예시2: FnMut</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[</span><span style="color:#75715e">derive(Debug)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Rectangle</span> {
    width: <span style="color:#66d9ef">u32</span>,
    height: <span style="color:#66d9ef">u32</span>,
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> list <span style="color:#f92672">=</span> [
        Rectangle {
            width: <span style="color:#ae81ff">10</span>,
            height: <span style="color:#ae81ff">1</span>,
        },
        Rectangle {
            width: <span style="color:#ae81ff">3</span>,
            height: <span style="color:#ae81ff">5</span>,
        },
        Rectangle {
            width: <span style="color:#ae81ff">7</span>,
            height: <span style="color:#ae81ff">12</span>,
        },
    ];

    <span style="color:#75715e">// (1) O
</span><span style="color:#75715e"></span>    list.sort_by_key(<span style="color:#f92672">|</span>r<span style="color:#f92672">|</span> r.width);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:#?}&#34;</span>, list);

    <span style="color:#75715e">// (2) X
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> sort_operations <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[];
    <span style="color:#66d9ef">let</span> value <span style="color:#f92672">=</span> String::from(<span style="color:#e6db74">&#34;by key called&#34;</span>);

    list.sort_by_key(<span style="color:#f92672">|</span>r<span style="color:#f92672">|</span> {
        sort_operations.push(value);
        r.width
    });
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:#?}&#34;</span>, list);

    <span style="color:#75715e">// (3) O
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> num_sort_operations <span style="color:#f92672">=</span> <span style="color:#ae81ff">0</span>;
    list.sort_by_key(<span style="color:#f92672">|</span>r<span style="color:#f92672">|</span> {
        num_sort_operations <span style="color:#f92672">+</span><span style="color:#f92672">=</span> <span style="color:#ae81ff">1</span>;
        r.width
    });
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{:#?}, sorted in {num_sort_operations} operations&#34;</span>, list);
}
</code></pre></div><ul>
<li>sort_by_key는 FnMut 구현이 필요한 슬라이스에 정의된 표준 라이브러리 메서드이다.</li>
<li>위 코드는 각 Rectangle의 width가 낮은 순서대로 정렬된다.</li>
<li>sort_by_key는 클로저를 여러 번 호출해야 하므로 FnMut 클로저를 인자로 받는다.</li>
<li><strong>(1)의 클로저는 어떤 값도 그 환경으로부터 바꾸지 않으므로 반복해서 호출 가능하다.</strong></li>
<li><strong>(2)의 클로저는 FnOnce를 구현하고 있으므로 해당 메서드에서 사용 불가능하다.</strong>
<ul>
<li>문자열 value를 sort_operations로 푸시할 때 클로저는 값을 캡처한다.</li>
<li>문자열 value의 소유권이 sort_operations로 벡터로 이동된다.</li>
<li>따라서 클로저를 다시 호출하려고 하면 에러가 난다.</li>
<li>즉, 이 클로저는 sort_by_key의 인자와 맞지 않다.</li>
<li>(3)은 클로저에서 환경 외부로 값의 소유권이 이동되지 않도록 변경했다.</li>
<li>(3)은 num_sort_operations에 대한 가변 참조만 캡처하므로 정상 동작한다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="iterator----">Iterator를 이용한 일련의 요소 처리</h2>
<h3 id="iterator-">Iterator 생성하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];

    <span style="color:#66d9ef">let</span> v1_iter <span style="color:#f92672">=</span> v1.iter();

    <span style="color:#66d9ef">for</span> val <span style="color:#66d9ef">in</span> v1_iter {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Got: {}&#34;</span>, val);
    }
}
</code></pre></div><ul>
<li>반복자는 요소를 순회하며 마지막 요소에 도달하는 때를 판단한다.</li>
<li><code>지연(lazy)</code>: 반복자를 사용하는 메서드 호출 전까지는 아무 일도 일어나지 않는다.</li>
<li><code>Vec&lt;T&gt;</code>에 정의된 iter 메서드를 호출해 v1에 대한 반복자를 생성하는 것 자체는 의미가 없다.</li>
<li>즉, v1_iter를 for 루프에서 비로소 사용할 때 의미가 있다.</li>
</ul>
<p><br /></p>
<h3 id="iterator--next-">Iterator 트레이트와 next 메서드</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Iterator {
    <span style="color:#66d9ef">type</span> <span style="color:#a6e22e">Item</span>;

    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">next</span>(<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">mut</span> self) -&gt; Option<span style="color:#f92672">&lt;</span>Self::Item<span style="color:#f92672">&gt;</span>;

    <span style="color:#75715e">// 기본 구현이 적용된 메서드는 생략
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>모든 반복자는 위 Iterator 트레이트를 구현해야 한다.</li>
<li>next 메서드는 컬렉션에서 값을 가져와 Some에 저장해 반환하고 모두 순회하면 None을 반환한다.</li>
<li>next 메서드는 Item 타입을 반환하고 있는데, 즉 Item은 반복자가 반환할 타입이다.<br />
<em><code>type Item</code>과 <code>Self::Item</code>은 연관타입으로, 19장에서 자세히 다룸</em></li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[</span><span style="color:#75715e">test</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">iterator_demonstration</span>() {
    <span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];

    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> v1_iter <span style="color:#f92672">=</span> v1.iter();

    assert_eq<span style="color:#f92672">!</span>(v1_iter.next(), Some(<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">1</span>));
    assert_eq<span style="color:#f92672">!</span>(v1_iter.next(), Some(<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">2</span>));
    assert_eq<span style="color:#f92672">!</span>(v1_iter.next(), Some(<span style="color:#f92672">&amp;</span><span style="color:#ae81ff">3</span>));
    assert_eq<span style="color:#f92672">!</span>(v1_iter.next(), None);

    <span style="color:#75715e">// let v1_iter = v1.iter();
</span><span style="color:#75715e"></span>
    <span style="color:#75715e">// for val in v1_iter {
</span><span style="color:#75715e"></span>    <span style="color:#75715e">//     v1_iter.next()
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// }
</span><span style="color:#75715e"></span>}
</code></pre></div><ul>
<li>Iterator 트레이트는 next 메서드 하나만 정의하고 있는데, 이를 직접 호출해도 된다.</li>
<li>이때 next 메서드를 호출하면 이미 반환한 값을 추적하기 위해 반복자 내부 상태가 변경된다.</li>
<li><strong>즉, v1_iter 변수는 반복자를 소비(consume)하므로 가변적으로 정의해야 한다.</strong></li>
<li><strong>그러나 for 안에서는 루프가 v1_iter의 소유권을 가지고 가변 변수로 만들기 때문에 불변해도 된다.</strong></li>
<li>종류:
<ul>
<li><code>iter</code>: 불변 참조를 순회하는 반복자를 생성</li>
<li><code>into_iter</code>: v1에 대한 소유권을 가지고 소유한 값을 반환하는 반복자 생성</li>
<li><code>iter_mut</code>: 가변 참조를 순회하는 반복자를 생성</li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="---sum">반복자를 소비하는 메서드: <code>sum</code></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[</span><span style="color:#75715e">cfg(test)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">mod</span> tests {
    <span style="color:#75715e">#[</span><span style="color:#75715e">test</span><span style="color:#75715e">]</span>
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">iterator_sum</span>() {
        <span style="color:#66d9ef">let</span> v1 <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];
        <span style="color:#66d9ef">let</span> v1_iter <span style="color:#f92672">=</span> v1.iter();
        <span style="color:#66d9ef">let</span> total: <span style="color:#66d9ef">i32</span> <span style="color:#f92672">=</span> v1_iter.sum();

        assert_eq<span style="color:#f92672">!</span>(total, <span style="color:#ae81ff">6</span>);
    }
}

</code></pre></div><ul>
<li>Iterator 트레이트를 구현하려면 next 메서드를 반드시 구현해야 한다.</li>
<li>next를 호출하는 메서드는 내부에서 반복자를 소비하므로 <code>consuming adaptors</code>라고도 부른다.</li>
<li>예를 들어, sum 메서드는 반복자에 대한 소유권을 가지고 next 메서드를 게속 호출해 순회한다.</li>
<li>sum 메서드를 호출한 후에는 v1_iter 변수의 소유권이 없으므로 더 이상 사용할 수 없다.</li>
</ul>
<p><br /></p>
<h3 id="----map">다른 반복자를 생성하는 메서드: <code>map</code></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> v1: Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">i32</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">1</span>, <span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>];

    <span style="color:#75715e">// (1)
</span><span style="color:#75715e"></span>    v1.iter().map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>);

    <span style="color:#75715e">// (2)
</span><span style="color:#75715e"></span>    <span style="color:#66d9ef">let</span> v2: Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> v1.iter().map(<span style="color:#f92672">|</span>x<span style="color:#f92672">|</span> x <span style="color:#f92672">+</span> <span style="color:#ae81ff">1</span>).collect();
    assert_eq<span style="color:#f92672">!</span>(v2, vec<span style="color:#f92672">!</span>[<span style="color:#ae81ff">2</span>, <span style="color:#ae81ff">3</span>, <span style="color:#ae81ff">4</span>]);
}

</code></pre></div><ul>
<li>반복자를 다른 종류의 반복자로 변경할 수 있는데, 이를 <code>iterator adaptors</code>라고 부른다.</li>
<li>모든 반복자는 지연 특성이 있어서 결과를 얻으려면 consuming adaptor 메서드를 호출해야 한다.</li>
<li>위 map 메서드의 클로저는 각 요소에 1을 더한 값을 반환해 새로운 반복자를 반환하고 있다.</li>
<li><strong>Iterator 트레이트의 반복 로직을 재사용하면서 일부 동작을 바꾸기 위해 클로저를 사용한 좋은 예다.</strong></li>
<li><strong>(1)은 반복자를 실제로 실행하지 않으므로 에러가 난다.</strong><br />
<em>warning: unused Map that must be used</em><br />
<em>note: iterators are lazy and do nothing unless consumed</em></li>
<li><strong>(2)는 반복자를 실행한 결과값을 컬렉션에 담아 반환하는 collect 메서드를 사용했다.</strong></li>
</ul>
<p><br /></p>
<h3 id="----filter">환경을 캡처하는 클로저 활용: <code>filter</code></h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">#[</span><span style="color:#75715e">derive(PartialEq, Debug)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Shoe</span> {
    size: <span style="color:#66d9ef">u32</span>,
    style: String,
}

<span style="color:#75715e">// shoes에 저장된 벡터와 shoe_size 매개변수의 소유권을 가지고
</span><span style="color:#75715e"></span><span style="color:#75715e">// 지정된 크기의 신발 리스트를 저장한 벡터를 반환함
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">shoes_in_size</span>(shoes: Vec<span style="color:#f92672">&lt;</span>Shoe<span style="color:#f92672">&gt;</span>, shoe_size: <span style="color:#66d9ef">u32</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>Shoe<span style="color:#f92672">&gt;</span> {
    <span style="color:#75715e">// into_iter로 벡터의 소유권을 가지는 반복자를 생성함
</span><span style="color:#75715e"></span>    <span style="color:#75715e">// filter 인자로 shoe_size 변수를 캡처하는 클로저 전달
</span><span style="color:#75715e"></span>    shoes.into_iter().filter(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s.size <span style="color:#f92672">=</span><span style="color:#f92672">=</span> shoe_size).collect()
}

<span style="color:#75715e">#[</span><span style="color:#75715e">cfg(test)</span><span style="color:#75715e">]</span>
<span style="color:#66d9ef">mod</span> tests {
    <span style="color:#66d9ef">use</span> <span style="color:#66d9ef">super</span>::<span style="color:#f92672">*</span>;

    <span style="color:#75715e">#[</span><span style="color:#75715e">test</span><span style="color:#75715e">]</span>
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">filters_by_size</span>() {
        <span style="color:#66d9ef">let</span> shoes <span style="color:#f92672">=</span> vec<span style="color:#f92672">!</span>[
            Shoe {
                size: <span style="color:#ae81ff">10</span>,
                style: String::from(<span style="color:#e6db74">&#34;sneaker&#34;</span>),
            },
            Shoe {
                size: <span style="color:#ae81ff">13</span>,
                style: String::from(<span style="color:#e6db74">&#34;sandal&#34;</span>),
            },
            Shoe {
                size: <span style="color:#ae81ff">10</span>,
                style: String::from(<span style="color:#e6db74">&#34;boot&#34;</span>),
            },
        ];

        <span style="color:#66d9ef">let</span> in_my_size <span style="color:#f92672">=</span> shoes_in_size(shoes, <span style="color:#ae81ff">10</span>);

        assert_eq<span style="color:#f92672">!</span>(
            in_my_size,
            vec<span style="color:#f92672">!</span>[
                Shoe {
                    size: <span style="color:#ae81ff">10</span>,
                    style: String::from(<span style="color:#e6db74">&#34;sneaker&#34;</span>)
                },
                Shoe {
                    size: <span style="color:#ae81ff">10</span>,
                    style: String::from(<span style="color:#e6db74">&#34;boot&#34;</span>)
                },
            ]
        );
    }
}
</code></pre></div><ul>
<li><strong>filter 메서드는 인자에 반복자로부터 각 요소를 가져와 불리언값을 반환하는 클로저를 전달한다.</strong></li>
<li>클로저가 true를 반환하면 filter가 생성하는 반복자에 추가되고, false이면 추가되지 않는다.</li>
<li>위 코드에서 클로저는 환경에서 shoe_size 매개변수를 캡처하고 값을 각 Shoe의 size와 비교한다.</li>
</ul>
<p><br /></p>
<hr />
<h2 id="12-io--">12장의 I/O 프로젝트 개선</h2>
<h3 id="-confignew-clone--">기존 Config::new의 clone이 필요한 이유?</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// minigrep
</span><span style="color:#75715e"></span><span style="color:#75715e">// src/lib.rs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> Config {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(args: <span style="color:#66d9ef">&amp;</span>[String]) -&gt; Result<span style="color:#f92672">&lt;</span>Config, <span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">if</span> args.len() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span> {
            <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;not enough arguments&#34;</span>);
        }

        <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">1</span>].clone();
        <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">2</span>].clone();

        <span style="color:#66d9ef">let</span> ignore_case <span style="color:#f92672">=</span> env::var(<span style="color:#e6db74">&#34;IGNORE_CASE&#34;</span>).is_ok();

        Ok(Config {
            query,
            filename,
            ignore_case,
        })
    }
}
</code></pre></div><ul>
<li>clone 메서드가 필요한 이유는 new 함수에 String의 슬라이스인 args 변수 소유권이 없기 때문이다.</li>
<li>따라서 Config 인스턴스가 복제된 값을 소유해 반환하도록 해야 했다.</li>
<li>이제 슬라이스를 대여하는 대신 인자로 전달된 반복자의 소유권을 갖도록 수정할 수 있다.</li>
<li>그러면 새로운 메모리 할당을 수행하는 대신, 반복자로부터 String값을 Config 인스턴스로 이동할 수 있다.</li>
</ul>
<p><br /></p>
<h3 id="-----2">리팩터링: 반환된 반복자를 직접 사용하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// AS-IS
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();

    <span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> Config::new(<span style="color:#f92672">&amp;</span>args).unwrap_or_else(<span style="color:#f92672">|</span>err<span style="color:#f92672">|</span> {
        eprintln<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Problem parsing arguments: {}&#34;</span>, err);
        process::exit(<span style="color:#ae81ff">1</span>);
    });

    ...
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// TO-BE
</span><span style="color:#75715e"></span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> Config::new(env::args()).unwrap_or_else(<span style="color:#f92672">|</span>err<span style="color:#f92672">|</span> {
        eprintln<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Problem parsing arguments: {}&#34;</span>, err);
        process::exit(<span style="color:#ae81ff">1</span>);
    });

    ...
}

<span style="color:#66d9ef">impl</span> Config {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(
        <span style="color:#66d9ef">mut</span> args: <span style="color:#a6e22e">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> String<span style="color:#f92672">&gt;</span>,
    ) -&gt; Result<span style="color:#f92672">&lt;</span>Config, <span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {...}
}
</code></pre></div><ul>
<li><code>env::args</code>는 반복자를 반환하는 함수다.</li>
<li>반복자의 값을 벡터로 합쳐 Config::new 슬라이스로 전달하는 대신, 반환한 반복자를 직접 전달시킨다.</li>
<li>Config::new의 args가 반복자 타입이도록 함수 시그니처도 변경한다.
<ul>
<li><strong>표준 라이브러리에 따르면 env::args 힘수의 반환 타입은 <code>std::env::Args</code>이다.</strong></li>
<li><strong>그리고 해당 타입은 Iterator 트레이트를 구현하고 String 값을 반환해야 한다.</strong></li>
<li>따라서 args는 <code> &amp;[String]</code> 대신 <code>impl Iterator&lt;Item = String&gt;</code> 타입을 가진다.</li>
<li>이때 impl trait 문법은 args가 Iterator 트레이트를 구현하면서 String 요소를 반환하는 어떤 타입도 가능하다는 뜻이다.</li>
<li>이때 args의 소유권을 가지고 반복자를 순회해야 하므로 args는 가변적이어야 한다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="---iterator---">리팩터링: 인덱스 대신 Iterator 트레이트 메서드 활용</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// AS-IS
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> Config {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(args: <span style="color:#66d9ef">&amp;</span>[String]) -&gt; Result<span style="color:#f92672">&lt;</span>Config, <span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">if</span> args.len() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span> {
            <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;not enough arguments&#34;</span>);
        }

        <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">1</span>].clone();
        <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">2</span>].clone();

        ...
    }
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// TO-BE
</span><span style="color:#75715e"></span><span style="color:#66d9ef">impl</span> Config {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(
        <span style="color:#66d9ef">mut</span> args: <span style="color:#a6e22e">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> String<span style="color:#f92672">&gt;</span>,
    ) -&gt; Result<span style="color:#f92672">&lt;</span>Config, <span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
        <span style="color:#75715e">// env::args 함수의 첫번째 반환값은 프로그램 이름임
</span><span style="color:#75715e"></span>        <span style="color:#75715e">// 따라서 단순히 next 호출함
</span><span style="color:#75715e"></span>        args.next();

        <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> args.next() {
            Some(arg) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> arg,
            None <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;Didn&#39;t get a query string&#34;</span>),
        };

        <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> args.next() {
            Some(arg) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> arg,
            None <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;Didn&#39;t get a file name&#34;</span>),
        };

        ...
    }
}
</code></pre></div><ul>
<li>이제 args는 Iterator 트레이트를 구현하므로 next 메서드를 호출할 수 있다.</li>
<li>각 값들에 대한 성공/실패 여부 동작을 위해 match 표현식을 사용한다.</li>
</ul>
<p><br /></p>
<h3 id="-iterator-adaptors----">리팩터링: Iterator adaptors를 사용해 깔끔한 코드 작성</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// AS-IS
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">search</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(query: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, contents: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> results <span style="color:#f92672">=</span> Vec::new();

    <span style="color:#66d9ef">for</span> line <span style="color:#66d9ef">in</span> contents.lines() {
        <span style="color:#66d9ef">if</span> line.contains(query) {
            results.push(line);
        }
    }

    results
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// TO-BE
</span><span style="color:#75715e"></span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">search</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(query: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, contents: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
    contents
        .lines()
        .filter(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> line.contains(query))
        .collect()
}
</code></pre></div><ul>
<li>반복자 어댑터 메서드들을 활용하면 코드가 더 직관적이고 중간값을 저장하는 변수도 필요없게 된다.</li>
<li>함수형 프로그래밍은 가변 상태를 최소화하므로 코드를 간결하게 유지할 수 있다.</li>
<li>루프를 실행하면서 새로운 벡터를 생성하는 대신, 루프의 목적을 고수준의 메서드로 퉁칠 수 있다.</li>
</ul>
<p><br /></p>
<h3 id="-minigrep--">리팩터링: minigrep 최종 코드</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// main.rs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::env;
<span style="color:#66d9ef">use</span> std::process;

<span style="color:#66d9ef">use</span> minigrep::Config;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> Config::new(env::args()).unwrap_or_else(<span style="color:#f92672">|</span>err<span style="color:#f92672">|</span> {
        eprintln<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Problem parsing arguments: {}&#34;</span>, err);
        process::exit(<span style="color:#ae81ff">1</span>);
    });

    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(e) <span style="color:#f92672">=</span> minigrep::run(config) {
        eprintln<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;애플리케이션 에러: {}&#34;</span>, e);

        process::exit(<span style="color:#ae81ff">1</span>);
    }
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// lib.rs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::fs;
<span style="color:#66d9ef">use</span> std::error::Error;
<span style="color:#66d9ef">use</span> std::env;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Config</span> {
  <span style="color:#66d9ef">pub</span> query: String,
  <span style="color:#66d9ef">pub</span> filename: String,
  <span style="color:#66d9ef">pub</span> ignore_case: <span style="color:#66d9ef">bool</span>,
}

<span style="color:#66d9ef">impl</span> Config {
    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(
        <span style="color:#66d9ef">mut</span> args: <span style="color:#a6e22e">impl</span> Iterator<span style="color:#f92672">&lt;</span>Item <span style="color:#f92672">=</span> String<span style="color:#f92672">&gt;</span>,
    ) -&gt; Result<span style="color:#f92672">&lt;</span>Config, <span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
        args.next();

        <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> args.next() {
            Some(arg) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> arg,
            None <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;Didn&#39;t get a query string&#34;</span>),
        };

        <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> <span style="color:#66d9ef">match</span> args.next() {
            Some(arg) <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> arg,
            None <span style="color:#f92672">=</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;Didn&#39;t get a file name&#34;</span>),
        };

        <span style="color:#66d9ef">let</span> ignore_case <span style="color:#f92672">=</span> env::var(<span style="color:#e6db74">&#34;IGNORE_CASE&#34;</span>).is_ok();

        Ok(Config {
            query,
            filename,
            ignore_case,
        })
    }
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(config: <span style="color:#a6e22e">Config</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Box<span style="color:#f92672">&lt;</span>dyn Error<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">let</span> contents <span style="color:#f92672">=</span> fs::read_to_string(config.filename)<span style="color:#f92672">?</span>;

  <span style="color:#66d9ef">let</span> results <span style="color:#f92672">=</span> <span style="color:#66d9ef">if</span> config.ignore_case {
      search_case_insensitive(<span style="color:#f92672">&amp;</span>config.query, <span style="color:#f92672">&amp;</span>contents)
  } <span style="color:#66d9ef">else</span> {
      search(<span style="color:#f92672">&amp;</span>config.query, <span style="color:#f92672">&amp;</span>contents)
  };

  <span style="color:#66d9ef">for</span> line <span style="color:#66d9ef">in</span> results {
      println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;{}&#34;</span>, line);
  }

  Ok(())
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">search</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(query: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, contents: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
    contents
        .lines()
        .filter(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> line.contains(query))
        .collect()
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">search_case_insensitive</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(
  query: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
  contents: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span>,
) -&gt; Vec<span style="color:#f92672">&lt;</span><span style="color:#f92672">&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> query.to_lowercase();

  contents
        .lines()
        .filter(<span style="color:#f92672">|</span>line<span style="color:#f92672">|</span> line.to_lowercase().contains(<span style="color:#f92672">&amp;</span>query))
        .collect()

}
</code></pre></div><p><br /></p>
<hr />
<h2 id="--loops-vs-iterators">성능 비교: Loops vs Iterators</h2>
</div>

</main>

        <footer>
            <p class="copyright text-muted">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>.</p>
        </footer>

        

        
    </body>

</html>

