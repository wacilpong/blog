---
title: "모두를 위한 클라우드 컴퓨팅 5"
date: "2022-10-15"
tags: ["cloud-computing"]
draft: false
---

## 컨테이너

- 샌드박스(sandbox)화된 런타임 환경
  - 샌드박스화되었다는 의미는 프로세스가 보호된 영역에서 동작한다는 것이다.
  - 따라서 호스트 시스템에 부정적인 영향을 미치는 것으로부터 보호한다.

<br />

### 패키징 기술 (Packaging technology)

- 컨테이너 기술은 패키징(packaging) 기술로 간단히 표현할 수 있다.
- 패키징의 대상은 애플리케이션과 이것이 동작할 수 있는 환경이다.
- 자신이 동작할 수 있는 환경을 포함하고 있으므로 쉽게 배포가 가능하다.
- 컨테이너 기반 애플리케이션 패키징
  - `Standard`: 규격화된 컨테이너 사용
  - `Portable`: 컨테이너는 이동이 가능
  - `Light weight`: 표준 컨테이너에 담을 수 있는 용량의 제한
  - `Security & Protection`: 컨테이너별 보안과 안전장치

<br />

### 가상화 vs 컨테이너

- 가상화에서는 물리적 컴퓨터 시스템 전체를 가상머신으로 만들고 그 운영체제를 가상머신에 설치한 상태로 배포한다.
  _ex. VMWare 머신 위에서 운영체제를 여러 개 띄운다._
  - 여러 운영체제가 하나의 하드웨어를 공유하고 운영체제들이 각 커널을 가진다.
  - 서로 독립된 운영체제를 구동하므로 컨테이너보다 오버헤드가 증가한다.
- 반면 컨테이너들은 컨테이너를 구동하는 운영체제의 `커널(kernel)`을 공유한다.
  _ex. Docker 이미지 여러 개를 하나의 운영체제 위에 띄운다._
  - 커널이란 하드웨어 시스템으로 접근할 수 있는 터널이라고 생각하면 쉽다.
  - 따라서 하나의 운영체제 안에서 여러 커널을 공유하므로 가상화보다 오버헤드가 적다.

<br />

### 컨테이너 기술의 역사

- 컨테이너의 핵심 기술은 분리(isolation)에 기반을 둔다.
- Unix V7: chroot를 통해 프로세스 간 분리를 할 수 있게됨
- FreeBSD Jail: Jail이라는 독립된 작은 시스템으로 나눠 커널을 공유
- Linux VServer: Jail처럼 운영체제 수준의 가상화로 시스템 리소스를 분리
- Solaris Containers: 존(zone) 개념 도입해 자원 분리
- Open VZ: 리눅스 커널 패치로 자원을 분리할 수 있는 기능 제공
- Process Container: 컴퓨터 자원 프로세스 사용량을 제한/격리하기 위함
- `LXC`: chroot의 확장된 형태로 현재 통용되는 컨테이너 기술의 시초
  _도커가 이를 컨테이너 엔진으로 초기에 사용함_
- `Docker`
  - 한번 구축하면 어느곳에서나 실행할 수 있는 `Build Once, Run Anyway` 실현
  - 프랑스의 dotCloud 회사에서 시작한 프로젝트이다.
  - 플랫폼에 사용할 기반 기술로 컨테이너를 활용하려는 목적이었다.
  - 따라서 플랫픔 서비스를 제공하기 위해 필요한 기술들을 도커에 적용하게 되었다.
  - 이에 따라 리눅스 컨테이너를 보편화할 수 있는 도커가 탄생했다.
- `Kubernetes`
  - 구글에서 2015년 7월에 오픈소스로 공개했다.
  - 2016년에 쿠버네티스를 CNCF(Cloud Native Computing Foundation)에 기증했다.
  - 따라서 VMWare, Azure, AWS, 도커에서 쿠버네티스를 자신의 인프라에서 지원할 수 있게 되었다.
  - 컨테이너화된 워크로드와 서비스를 관리할 수 있는 대표 오케스트레이션 툴이다.
- Container Security Issue
  - 컨테이너를 적용한 앱들이 활발하게 사용되면서 Dirty COW와 같은 보안문제가 발생했다.
    _리눅스 커널에서 readonly 메모리 복사할 때 race condition을 발생시키는 이슈_
    _이를 통해 write 권한을 얻을 수 있어, 일반 권한 사용자가 root 권한 상승 시도_
- OCI(Open Container Initiative)
  - 도커가 컨테이너 기반의 서비스 활성화에 기여한 것은 사실이다.
  - 그러나 특정한 솔루션에 과도하게 의존하는 것을 경계하기 위해 컨테이너 포맷과 런타임에 대한 개방형 표준을 만들었다.
  - OCI 표준을 따르는 런타임으로 CRI-O(Container Runtime Interface-OCI)가 개발되었다.
  - 초기 컨테이너 런타임은 도커만 있었지만, CRI-O, RKT, Containerd가 등장했다.
  - 컨테이너 런타임을 제어하는 것을 오케스트레이션이라고 한다.
    _이에 대한 표준을 따르는 구현체가 바로 쿠버네티스이다._

<br />

### 컨테이너 vs 가상머신

```s
(1) 머신 가상화
App1      App2      App3
Bins/Lib  Bins/Lib  Bins/Lib
게스트 OS   게스트 OS   게스트 OS
--------- 하이퍼바이저 ---------
-------- 인프라스트럭처 --------
```

```s
(2) 컨테이너
App1      App2      App3
Bins/Lib  Bins/Lib  Bins/Lib
-------- 컨테이너 엔진 --------
---------- 운영체제 ----------
-------- 인프라스트럭처 --------
```

- 컨테이너는 가상화인가? _Not Exactly_
- 컨테이너에서 동작하는 앱이 독립된 환경에서 실행되고 다른 컨테이너 앱에 영향을 미치지 않는다는 점은 가상화와 유사하다.
- 그러나 컨테이너는 가상화처럼 가상머신별 독립된 운영체제가 동작할 수 없다. (ex. VMWare)
- 컨테이너는 운영체제를 분리하는 게 아니라, 앱을 운영체제로부터 독립시킨다.
  - x86 리눅스는 x86 리눅스 컨테이너를, x86 윈도우 운영체제는 x86 윈도우 컨테이너를 써야 한다.
  - 즉, 서로 다른 운영체제 기반의 컨테이너는 단일 머신에서 실행될 수 없다.
- 가상화는 하이퍼바이저를 이용해 여러 개의 운영체제를 실행하기 때문에 컨테이너처럼 경량 구조가 아니다.

<br />

### 컨테이너가 유리한 경우

- 애플리케이션이 `멀티서비스(multiservice)` 아키텍처인 경우
  _마이크로서비스(microservice)라고 한다._
  _독립적으로 배포할 수 있는 소규모 서비스의 모음_
  _ex. 카카오 결제 서버 하나가 죽어도 다른 서비스들은 돌아가는 것_
- 애플리케이션이 동작하는 서버의 수를 최소화하고자 하는 경우
- 클라우드 네이티브 애플리케이션을 개발하고자 하는 경우
- 애플리케이션 개발환경이 배포환경과 유사한 경우

<br />

### 가상머신이 유리한 경우

- 애플리케이션이 `모놀리식(monolithic)` 아키텍처인 경우
  _모든 서비스(결제, 쇼핑, 스토리지 등)를 하나의 인스턴스로 관리하는 전통적인 구조_
  _하드웨어 메모리를 늘리는 식으로 업그레이드를 할 수밖에 없다._
- 서로 다른 운영체제가 필요한 경우
- 플랫폼에 고정된 스토리지 시스템이 필요한 경우
- 운영체제의 많은 기능이 필요한 경우

<br />
<hr />

## 도커 (Docker)

- 응용프로그램을 컨테이너로 실행하고 관리할 수 있는 오픈소스 프로젝트이다.
- 도커를 이용해 앱이 수행될 인프라스트럭처와 앱을 분리할 수 있고 쉽고 빠르게 배포할 수 있다.
- 리눅스에서 운영체제 수준의 가상화를 제공하는 `PaaS` 제품이라고 볼 수 있다.
- 컨테이너 안의 소프트웨어들은 동작에 필요한 모든 파일들을 포함하고 있다.
- 도커는 실행되는 시스템의 제약을 받지 않으므로 물리머신 혹은 가상머신에서도 실행될 수 있다.
- 컨테이너는 이미지로 저장된다.
  _이미지는 실행가능한 패키지이고, 코드/런타임/라이브러리/환경변수/설정파일이 들어 있다._
  _생성되는 컨테이너는 `docker ps` 명령어로 도커 컨테이너를 확인할 수 있다._

<br />

### 구동 방식
