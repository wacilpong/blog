<!DOCTYPE html>
<html lang="kr-ko">
    <head>
        <meta name="description" content="An I/O Project: Building a Command Line Program" />

<meta name="og:type" content="website" />
<meta property="og:title" content="After reading Rust book chapter 12" />
<meta property="og:site_name" content="After reading Rust book chapter 12" />
<meta property="og:description" content="An I/O Project: Building a Command Line Program" />
<meta property="og:url" content="https://wacilpong.github.io/blog/study/rust/rust-12/" />

<meta name="twitter:card" content="summary" />
<meta name="twitter:title" content="After reading Rust book chapter 12" />
<meta name="twitter:description" content="An I/O Project: Building a Command Line Program" />

<meta property="og:image" content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512" />
<meta
  property="twitter:image:src"
  content="https://ca.slack-edge.com/T17RWEQDQ-UHVBKS9HA-41689aac3b87-512"
/>


<script
  async
  src="https://www.googletagmanager.com/gtag/js?id=UA-171393148-1"
></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag() {
    dataLayer.push(arguments);
  }
  gtag("js", new Date());

  gtag("config", "UA-171393148-1");
</script>

        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>After reading Rust book chapter 12</title>
        
            <link rel="icon" href="https://wacilpong.github.io/blog/favicon.ico">
        
        <style>

    html body {
        font-family: 'Raleway', sans-serif;
        background-color: white;
    }

    :root {
        --accent: #469160;
        --border-width:  5px ;
    }

</style>


<link rel="stylesheet" href="https://wacilpong.github.io/blog/css/main.css">


 <link rel="stylesheet" href="https://wacilpong.github.io/blog/css/custom.css"> 


<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Raleway">


 <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/solarized-dark.min.css"> 


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">


<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" integrity="sha384-wvfXpqpZZVQGK6TAh5PVlGOfQNHSoD2xbE+QkPxCAFlNEevoEH3Sl0sibVcOQVnN" crossorigin="anonymous">
 

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
    
    <script>hljs.initHighlightingOnLoad();</script>






<script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>


<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script>


<script>$(document).on('click', function() { $('.collapse').collapse('hide'); })</script>
 <meta name="generator" content="Hugo 0.62.0" />
        

        

        
            <script type="text/javascript" async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
        

        

    </head>

    <body>
        

        <nav class="navbar navbar-default navbar-fixed-top">
            <div class="container">
                <div class="navbar-header">
                    <a class="navbar-brand visible-xs" href="#">After reading Rust book chapter 12</a>
                    <button class="navbar-toggle" data-target=".navbar-collapse" data-toggle="collapse">
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                </div>
                <div class="collapse navbar-collapse">
                    
                        <ul class="nav navbar-nav">
                            
                                <li><a href="/blog/">Home</a></li>
                            
                                <li><a href="/blog/tags/">Category</a></li>
                            
                                <li><a href="/blog/post/">Posts</a></li>
                            
                                <li><a href="/blog/project/">Projects</a></li>
                            
                                <li><a href="/blog/learned/">What I Learned</a></li>
                            
                        </ul>
                    
                    
                        <ul class="nav navbar-nav navbar-right">
                            
                                <li class="navbar-icon"><a href="https://github.com/wacilpong/"><i class="fa fa-github"></i></a></li>
                            
                                <li class="navbar-icon"><a href="https://www.linkedin.com/in/areum-han-a10645118/"><i class="fa fa-linkedin"></i></a></li>
                            
                        </ul>
                    
                </div>
            </div>
        </nav>


<main>

    <div>
        <h2>After reading Rust book chapter 12</h2>
        <h5></h5>
        
<a href="https://wacilpong.github.io/blog/tags/rust"><kbd class="item-tag">rust</kbd></a>


    </div>

    <div align="start" class="content"><h2 id="accepting-command-line-arguments">Accepting Command Line Arguments</h2>
<h3 id="reading-the-argument-values">Reading the Argument Values</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::env;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">2</span>];

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;검색어: {}&#34;</span>, query);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;대상 파일: {}&#34;</span>, filename);
}
</code></pre></div><ul>
<li>커맨드의 인수를 읽기 위해 표준 라이브러리의 <code>args</code> 함수를 사용해야 한다.</li>
<li><code>collect</code> 함수는 다양한 종류의 컬렉션을 만들 수 있다.</li>
<li>따라서 args 변수 타입을 문자열의 벡터로 명시해야 한다.</li>
<li>러스트에서 타입을 명시할 일이 거의 없지만, collect 함수는 반드시 명시해야 한다.</li>
<li>args[0]에는 프로그램의 이름이 저장되어 있으므로 인덱스 1부터 사용한다.</li>
<li>위 코드에 <code>cargo run hi test.txt</code>를 실행한 결과값:<br />
<em>검색어: hi 대상 파일: test.txt</em></li>
</ul>
<p><br /></p>
<h3 id="reading-a-file">Reading a File</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::env;
<span style="color:#66d9ef">use</span> std::fs;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">2</span>];

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;검색어: {}&#34;</span>, query);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;대상 파일: {}&#34;</span>, filename);

    <span style="color:#66d9ef">let</span> contents <span style="color:#f92672">=</span> fs::read_to_string(filename).expect(<span style="color:#e6db74">&#34;파일을 읽지 못했습니다.&#34;</span>);

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;파일 내용:\n{}&#34;</span>, contents);
}
</code></pre></div><ul>
<li>파일 처리를 위해 표준 라이브러리 fs 모듈의 <code>read_to_string</code> 함수를 사용해야 한다.</li>
<li>해당 함수는 파일의 내용을 <code>Result&lt;String&gt;</code> 타입으로 반환한다.</li>
<li>해당 프로젝트 루트에 poem.txt 파일을 만들어서 실행하면 된다.</li>
<li>위 코드는 다음의 개선할만한 지점이 있다.
<ul>
<li>main 함수가 인수 처리와 파일 열기 2가지 작업을 하고 있어 분리가 필요하다.</li>
<li>filename, contents 등 설정 변수들을 구조체로 묶어 목적을 명확히 해야 한다.</li>
<li>에러 메시지가 너무 단순하므로 다양한 상황을 잡을 수 있어야 한다.</li>
<li>필요한 인수를 구체화하지 않아 인덱스 범위를 벗어났다는 러스트 에러가 발생한다.</li>
</ul>
</li>
</ul>
<p><br /></p>
<hr />
<h2 id="refactoring-to-improve-modularity-and-error-handling">Refactoring to Improve Modularity and Error Handling</h2>
<h3 id="---">바이너리 프로젝트의 관심 분리</h3>
<h4 id="1---">(1) 인수 구문분석 분리하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
  ...
  <span style="color:#66d9ef">let</span> (query, filename) <span style="color:#f92672">=</span> parse_config(<span style="color:#f92672">&amp;</span>args);
  ...
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_config</span>(args: <span style="color:#66d9ef">&amp;</span>[String]) -&gt; (<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">str</span>, <span style="color:#f92672">&amp;</span><span style="color:#66d9ef">str</span>) {
    <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">1</span>];
    <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> <span style="color:#f92672">&amp;</span>args[<span style="color:#ae81ff">2</span>];

    (query, filename)
}
</code></pre></div><ul>
<li>main 함수가 여러 작업을 수행하는 책임 문제는 바이너리 프로젝트에서 쉽게 찾을 수 있다.</li>
<li>러스트는 바이너리 프로그램의 main 함수의 관심을 분리하기 위한 지침을 제공한다:
<ul>
<li>프로그램을 main.rs와 lib.rs로 분리하고 로직을 lib.rs 파일로 옮긴다.</li>
<li>커맨드 구문분석 로직이 충분히 작다면 main.rs 파일에 남겨둔다.</li>
<li>커맨드 구문분석 로직이 복잡해지기 시작하면 main.rs에서 추출해 lib.rs로 옮긴다.</li>
</ul>
</li>
<li><code>parse_config</code>는 main 함수에서 인수 구문분석 로직만 추출해온 함수다.</li>
<li>지금처럼 작은 프로그램에서는 과도하게 보이지만, 점진적 리팩토링을 위해 필요하다.</li>
</ul>
<p><br /></p>
<h4 id="2--">(2) 설정값의 그룹화</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
  ...
  <span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> parse_config(<span style="color:#f92672">&amp;</span>args);
  ...
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Config</span> {
    query: String,
    filename: String
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parse_config</span>(args: <span style="color:#66d9ef">&amp;</span>[String]) -&gt; <span style="color:#a6e22e">Config</span> {
    <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">1</span>].clone();
    <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">2</span>].clone();

    Config { query, filename }
}
</code></pre></div><ul>
<li>튜플 대신 관련있는 필드를 묶어 <code>Config</code> 구조체를 생성하고, 두 값이 연관있음을 표현한다.</li>
<li>직접 String 값을 소유하는 Config 인스턴스를 반환하는 이유:
<ul>
<li>인수값의 소유권은 main 함수의 args 매개변수에 있으며, <code>parse_config</code> 함수는 이 값을 대여하고 있다.</li>
<li>즉, Config 구조체가 args 벡터의 값에 대한 소유권을 가지려고 하면 러스트 대여 규칙을 위반하는 셈이다.</li>
<li><strong>따라서 clone 메서드를 호출해 복제본을 만드는데, 문자열 데이터의 참조를 저장할 때보다 메모리 소모는 크지만, 참조 수명을 관리할 필요가 없다. (트레이드오프)</strong></li>
</ul>
</li>
</ul>
<p><br /></p>
<h4 id="3-config--">(3) Config 구조체의 생성자</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
  ...
  <span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> Config::new(<span style="color:#f92672">&amp;</span>args);
  ...
}

<span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Config</span> {
    query: String,
    filename: String
}

<span style="color:#66d9ef">impl</span> Config {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(args: <span style="color:#66d9ef">&amp;</span>[String]) -&gt; <span style="color:#a6e22e">Config</span> {
        <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">1</span>].clone();
        <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">2</span>].clone();

        Config { query, filename }
    }
}
</code></pre></div><ul>
<li>생각해보면 <code>parse_config</code> 함수의 목적은 Config 인스턴스를 생성하는 것이다.</li>
<li>따라서 더욱 보편적인 패턴에 따라 Config 구조체의 연관함수로 바꾸는 편이 낫다.</li>
</ul>
<p><br /></p>
<h3 id="--">에러 처리 개선하기</h3>
<ul>
<li>args 벡터가 3개보다 적으면 인덱스 1과 2를 참조할 때 패닉이 발생한다.<br />
<em>index out of bounds: the len is 1 but the index is 1</em></li>
<li>최종 사용자 입장에서는 왜 이런 에러가 발생하는지 알 수 없으므로 개선해야 한다.</li>
</ul>
<p><br /></p>
<h4 id="1----1">(1) 에러 메시지 개선하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> Config {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(args: <span style="color:#66d9ef">&amp;</span>[String]) -&gt; <span style="color:#a6e22e">Config</span> {
        <span style="color:#66d9ef">if</span> args.len() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span> {
            panic<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;필요한 인수가 지정되지 않았습니다.&#34;</span>);
        }

        <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">1</span>].clone();
        <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">2</span>].clone();

        Config { query, filename }
    }
}
</code></pre></div><ul>
<li>new 연관함수에 길이가 충분한지 검사하는 코드를 추가했다.</li>
<li>그러나 <code>panic!</code> 매크로는 사용상의 문제보다 프로그래밍적 문제에 적합하다.</li>
<li>따라서 작업의 성공/실패 여부를 의미하는 Result 타입을 반환하도록 하자.</li>
</ul>
<p><br /></p>
<h4 id="2-panic----result-">(2) panic! 매크로 호출 대신 Result 반환하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">impl</span> Config {
    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(args: <span style="color:#66d9ef">&amp;</span>[String]) -&gt; Result<span style="color:#f92672">&lt;</span>Config, <span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
        <span style="color:#66d9ef">if</span> args.len() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span> {
            <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;필요한 인수가 지정되지 않았습니다.&#34;</span>);
        }

        <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">1</span>].clone();
        <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">2</span>].clone();

        Ok(Config { query, filename })
    }
}
</code></pre></div><ul>
<li>작업이 성공하면 Config 인스턴스를 반환하고, 그렇지 않으면 에러메시지를 반환한다.</li>
<li>이때 <code>&amp;'static str</code>은 정적 수명을 가진 문자열 리터럴 타입이며 에러메시지를 저장하기 위함이다.</li>
</ul>
<p><br /></p>
<h4 id="3-confignew----">(3) Config::new 함수 호출하고 에러 처리하기</h4>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">use</span> std::process;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
  ...
  <span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> Config::new(<span style="color:#f92672">&amp;</span>args).unwrap_or_else(<span style="color:#f92672">|</span>err<span style="color:#f92672">|</span> {
      println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Problem parsing arguments: {}&#34;</span>, err);
      process::exit(<span style="color:#ae81ff">1</span>);
  });
  ...
}
</code></pre></div><ul>
<li>0이 아닌 상태는 프로그램을 호출한 프로세스에게 프로그램이 에러 상태여서 종료되었음을 알리는 규칙이다.</li>
<li><code>unwrap_or_else</code>는 표준 라이브러리가 <code>Result&lt;T, E&gt;</code>타입에 정의한 메서드다.
<ul>
<li>panic! 매크로가 아닌 다른 방법으로 에러를 처리할 수 있다.</li>
<li>Ok 값이면 그 열거값에 저장된 값을 반환한다.</li>
<li><strong>Err 값이면 클로저를 이용해 해당 메서드에 전달한 익명함수를 호출한다.</strong></li>
<li><strong>Err에 저장되는 값은 익명함수의 파이프 문자(|) 사이에 선언하는 인수에 전달된다.</strong></li>
</ul>
</li>
</ul>
<p><br /></p>
<h3 id="main---">main 함수에서 로직 분리하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    <span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> Config::new(<span style="color:#f92672">&amp;</span>args).unwrap_or_else(<span style="color:#f92672">|</span>err<span style="color:#f92672">|</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Problem parsing arguments: {}&#34;</span>, err);
        process::exit(<span style="color:#ae81ff">1</span>);
    });

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;검색어: {}&#34;</span>, config.query);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;대상 파일: {}&#34;</span>, config.filename);

    run(config);
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(config: <span style="color:#a6e22e">Config</span>) {
    <span style="color:#66d9ef">let</span> contents <span style="color:#f92672">=</span> fs::read_to_string(config.filename).expect(<span style="color:#e6db74">&#34;파일을 읽지 못했습니다.&#34;</span>);

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;파일 내용:\n{}&#34;</span>, contents);
}
</code></pre></div><ul>
<li>현재 작성된 코드에서 설정, 에러처리와 관련되지 않은 코드를 분리할 수 있다.</li>
<li>main 함수를 더 쉽게 검증할 수 있으며 나머지 로직에 대한 테스트도 작성할 수 있다.</li>
</ul>
<p><br /></p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust">...
<span style="color:#66d9ef">use</span> std::error::Error;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    ...
    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(e) <span style="color:#f92672">=</span> run(config) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;애플리케이션 에러: {}&#34;</span>, e);
        process::exit(<span style="color:#ae81ff">1</span>);
    }
}

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(config: <span style="color:#a6e22e">Config</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Box<span style="color:#f92672">&lt;</span>dyn Error<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> {
    <span style="color:#66d9ef">let</span> contents <span style="color:#f92672">=</span> fs::read_to_string(config.filename)<span style="color:#f92672">?</span>;

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;파일 내용:\n{}&#34;</span>, contents);

    Ok(())
}
</code></pre></div><ul>
<li>run 함수는 원래 유닛타입을 반환했으므로 Ok인 경우 유지한다.</li>
<li><code>Box&lt;dyn Error&gt;</code>는 트레이트 객체로 함수가 Error 트레이트를 구현하는 타입을 반환하지만, 반환될 값의 타입은 특정하지 않는다는 의미이다.</li>
<li><strong>panic! 매크로 호출 대신 <code>?</code> 연산자를 사용하면 현재 함수의 호출자에게 에러값을 반환할 수 있다.</strong></li>
<li>run 함수는 성공 시 ()를 반환하므로 오로지 에러가 발생했는지만 파악하면 된다.</li>
<li>따라서 <code>unwrap_or_else</code>를 이용해 ()값을 얻어올 필요가 없다.</li>
<li>if let 구문과 기존 unwrap_or_else 함수 본문은 같다.</li>
<li>즉, 에러메시지 출력 후 프로그램을 종료한다.</li>
</ul>
<p><br /></p>
<h3 id="---1">라이브러리 크레이트로 분리하기</h3>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// lib.rs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::fs;
<span style="color:#66d9ef">use</span> std::error::Error;

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">Config</span> {
  <span style="color:#66d9ef">pub</span> query: String,
  <span style="color:#66d9ef">pub</span> filename: String
}

<span style="color:#66d9ef">impl</span> Config {
  <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">new</span>(args: <span style="color:#66d9ef">&amp;</span>[String]) -&gt; Result<span style="color:#f92672">&lt;</span>Config, <span style="color:#f92672">&amp;</span>&#39;static <span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> {
      <span style="color:#66d9ef">if</span> args.len() <span style="color:#f92672">&lt;</span> <span style="color:#ae81ff">3</span> {
          <span style="color:#66d9ef">return</span> Err(<span style="color:#e6db74">&#34;필요한 인수가 지정되지 않았습니다.&#34;</span>);
      }

      <span style="color:#66d9ef">let</span> query <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">1</span>].clone();
      <span style="color:#66d9ef">let</span> filename <span style="color:#f92672">=</span> args[<span style="color:#ae81ff">2</span>].clone();

      Ok(Config { query, filename })
  }
}

<span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">run</span>(config: <span style="color:#a6e22e">Config</span>) -&gt; Result<span style="color:#f92672">&lt;</span>(), Box<span style="color:#f92672">&lt;</span>dyn Error<span style="color:#f92672">&gt;</span><span style="color:#f92672">&gt;</span> {
  <span style="color:#66d9ef">let</span> contents <span style="color:#f92672">=</span> fs::read_to_string(config.filename)<span style="color:#f92672">?</span>;

  println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;파일 내용:\n{}&#34;</span>, contents);

  Ok(())
}
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-rust" data-lang="rust"><span style="color:#75715e">// main.rs
</span><span style="color:#75715e"></span><span style="color:#66d9ef">use</span> std::env;
<span style="color:#66d9ef">use</span> std::process;

<span style="color:#66d9ef">use</span> minigrep::Config;

<span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">main</span>() {
    <span style="color:#66d9ef">let</span> args: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> env::args().collect();
    <span style="color:#66d9ef">let</span> config <span style="color:#f92672">=</span> Config::new(<span style="color:#f92672">&amp;</span>args).unwrap_or_else(<span style="color:#f92672">|</span>err<span style="color:#f92672">|</span> {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Problem parsing arguments: {}&#34;</span>, err);
        process::exit(<span style="color:#ae81ff">1</span>);
    });

    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;검색어: {}&#34;</span>, config.query);
    println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;대상 파일: {}&#34;</span>, config.filename);

    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Err(e) <span style="color:#f92672">=</span> minigrep::run(config) {
        println<span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;애플리케이션 에러: {}&#34;</span>, e);
        process::exit(<span style="color:#ae81ff">1</span>);
    }
}
</code></pre></div><ul>
<li>이제 lib.rs는 테스트할 수 있는 공개 API를 갖게 된 셈이다.</li>
<li>따라서 main.rs에서 스코프로 가져와서 사용할 수 있다.</li>
</ul>
</div>

</main>

        <footer>
            <p class="copyright text-muted">© All rights reserved. Powered by <a href="https://gohugo.io">Hugo</a> and <a href="https://github.com/calintat/minimal">Minimal</a>.</p>
        </footer>

        

        
    </body>

</html>

